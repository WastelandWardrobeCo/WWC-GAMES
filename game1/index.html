<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Zone 13 | v0.2.7f Phase 4 Power Coupling</title>
<style>
    :root{
      --bg:#070b0e; --panel:#0d141a; --panel2:#0a1015; --border:#1b2a33;
      --ink:#d6dee6; --muted:#8ea0ad;
      --good:#22c55e; --warn:#eab308; --bad:#ef4444; --cyan:#22d3ee;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    .app{height:100%;display:grid;grid-template-columns:380px 1fr 420px;gap:12px;padding:12px;}

    .centerCol{display:flex;flex-direction:column;gap:12px;min-width:640px;}

    .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;box-shadow:var(--shadow);padding:12px;overflow:hidden;}
    .panel h2{margin:0 0 10px 0;font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:var(--muted);}
    .hintBox{position:absolute;left:16px;top:92px;max-width:340px;background:rgba(10,16,21,.78);border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px 12px;color:var(--ink);backdrop-filter:blur(6px);pointer-events:none;}
    .hintBox b{color:var(--cyan);}

    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;font-variant-numeric:tabular-nums;}
    .row{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:7px 0;border-bottom:1px solid rgba(255,255,255,.06);}
    .row:last-child{border-bottom:none;}
    .k{font-size:12px;color:var(--muted);}
    .v{font-size:13px;}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:2px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);font-size:12px;}
    .pill.good{color:var(--good);border-color:rgba(34,197,94,.35);}
    .pill.warn{color:var(--warn);border-color:rgba(234,179,8,.35);}
    .pill.bad{color:var(--bad);border-color:rgba(239,68,68,.35);}
    .pill.cyan{color:var(--cyan);border-color:rgba(34,211,238,.35);}
    button{background:#0a1116;border:1px solid var(--border);color:var(--ink);
      padding:8px 10px;border-radius:10px;cursor:pointer;font-size:13px;}
    button:hover{border-color:rgba(34,211,238,.45);color:var(--cyan);}
    button[disabled]{opacity:.45;cursor:not-allowed;}
    .glowPulse{
      animation: pulse 1.4s ease-in-out infinite;
      border-color: rgba(34,211,238,.55) !important;
      box-shadow: 0 0 0 2px rgba(34,211,238,.10), 0 0 22px rgba(34,211,238,.25);
      color: var(--cyan) !important;
    }
    @keyframes pulse{
      0%{ box-shadow: 0 0 0 2px rgba(34,211,238,.06), 0 0 18px rgba(34,211,238,.12); }
      50%{ box-shadow: 0 0 0 2px rgba(34,211,238,.14), 0 0 30px rgba(34,211,238,.28); }
      100%{ box-shadow: 0 0 0 2px rgba(34,211,238,.06), 0 0 18px rgba(34,211,238,.12); }
    }

    .topbar{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;}
    .brand{display:flex;flex-direction:column;gap:2px;}
    .brand .title{font-size:13px;letter-spacing:.08em;text-transform:uppercase;color:#b9c8d4;}
    .brand .sub{font-size:12px;color:var(--muted);}
    .tools{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end;}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:999px;border:1px solid var(--border);background:var(--panel2);font-size:12px;color:#cfe0ee;}
    .mapPanel{display:grid;grid-template-rows:auto 1fr;gap:12px;min-width:0;}
    .map{background:linear-gradient(180deg, rgba(34,211,238,.04), rgba(0,0,0,0));
      border:1px solid var(--border);border-radius:14px;position:relative;overflow:hidden;
      display:flex;align-items:center;justify-content:center;min-height:560px;}
    canvas{display:block; width:100%; height:100%;}
    .overlayHint{
      position:absolute; left:14px; top:14px;
      padding:8px 10px; border-radius:12px;
      background:rgba(9,16,22,.80); border:1px solid rgba(255,255,255,.10);
      font-size:12px; color:#cfe0ee;
    }
    .overlayHint b{color:var(--cyan); font-weight:600;}
    .rightCol{display:flex;flex-direction:column;gap:12px;min-width:0;align-self:stretch;}

    .box{background:var(--panel2);border:1px solid var(--border);border-radius:12px;padding:10px;}
    .sectionTitle{display:flex;align-items:center;justify-content:space-between;gap:10px;}

    .item{background:#070c10;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px;
      display:flex;align-items:flex-start;justify-content:space-between;gap:12px;margin-top:8px;}
    .itemTitle{font-size:13px;}
    .itemMeta{font-size:12px;color:var(--muted);margin-top:4px;line-height:1.35;}
    .itemRight{display:flex;flex-direction:column;align-items:flex-end;gap:6px;}
    .tag{display:inline-flex;align-items:center;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
      font-size:11px;color:#cfe0ee;background:rgba(10,16,21,.8);}
    .tag.locked{color:#b3c1cc;border-color:rgba(255,255,255,.10);opacity:.9;}
    .tag.built{color:var(--good);border-color:rgba(34,197,94,.25);}
    .tag.owned{color:#7dd3fc;border-color:rgba(125,211,252,.25);}

    .invRow{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px 0;border-bottom:1px solid rgba(255,255,255,.06);}
    .invRow:last-child{border-bottom:none;}
    .invName{font-size:12px;color:#cfe0ee;}
    .invCount{font-size:12px;color:var(--muted);}
    .log{min-height:190px;background:#070c10;border:1px solid var(--border);border-radius:12px;
      padding:10px;overflow:auto;white-space:pre-wrap;font-size:12px;line-height:1.35;color:#c6d3de;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;}

    @media (max-width: 520px){ .app{grid-template-columns:1fr;} }
  
    .phaseOverlay{
      position:absolute;
      top:14px;
      left:50%;
      transform:translateX(-50%);
      padding:10px 12px;
      border-radius:12px;
      background:rgba(6,12,18,.78);
      border:1px solid rgba(255,255,255,.12);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      z-index:55;
      min-width:340px;
      text-align:center;
    }
    .phaseTitle{font:700 12px ui-monospace; letter-spacing:.5px; color:rgba(214,222,230,.95);}
    .phaseObj{margin-top:4px; font:500 11px ui-monospace; color:rgba(214,222,230,.78); line-height:1.25;}
    .phaseProg{margin-top:6px; font:700 12px ui-monospace; color:rgba(34,197,94,.90);}

  
    .phaseOverlay.phaseReady{
      border-color: rgba(34,197,94,.55);
      box-shadow: 0 0 0 2px rgba(34,197,94,.18), 0 10px 30px rgba(0,0,0,.35);
      animation: phaseGlow 1.1s ease-in-out infinite;
    }
    @keyframes phaseGlow{
      0%{ box-shadow:0 0 0 2px rgba(34,197,94,.10), 0 10px 30px rgba(0,0,0,.35); }
      50%{ box-shadow:0 0 0 2px rgba(34,197,94,.26), 0 0 22px rgba(34,197,94,.16), 0 10px 30px rgba(0,0,0,.35); }
      100%{ box-shadow:0 0 0 2px rgba(34,197,94,.10), 0 10px 30px rgba(0,0,0,.35); }
    }
    .confetti{ position:absolute; inset:0; pointer-events:none; overflow:hidden; }
    .confetti i{
      position:absolute;
      width:6px; height:10px;
      border-radius:2px;
      opacity:.0;
      transform: translateY(-10px) rotate(0deg);
    }
    .phaseOverlay.celebrate .confetti i{
      opacity:1;
      animation: confettiFall 900ms ease-out forwards;
    }
    @keyframes confettiFall{
      0%{ transform: translateY(-8px) rotate(0deg); opacity:0; }
      10%{ opacity:1; }
      100%{ transform: translateY(62px) rotate(220deg); opacity:0; }
    }

  
    .overlayHint, .hintBox, #hintBox, #onboardingHint, .onboardingHint { display:none !important; }

  
    .app{
      display:grid !important;
      grid-template-columns: 280px minmax(720px, 1fr) 360px !important;
      grid-template-rows: 1fr !important;
      gap: 14px !important;
      width: 100% !important;
      height: 100vh !important;
      overflow: hidden !important;
      align-items: stretch !important;
    }
    .hud{ grid-column:1; grid-row:1; min-width: 260px; }
    .centerCol, .center, .main, main{ grid-column:2; grid-row:1; min-width: 720px; }
    .right, .rightPanel, #rightPanel, aside.right{ grid-column:3; grid-row:1; min-width: 320px; }
    @media (max-width: 1200px){
      .app{ grid-template-columns: 260px minmax(560px,1fr) 320px !important; }
    }
    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr !important; grid-template-rows:auto auto auto !important; height:auto !important; overflow:auto !important; }
      .hud{ grid-column:1; grid-row:1; }
      .centerCol, .center, .main, main{ grid-column:1; grid-row:2; min-width: 0 !important; }
      .right, .rightPanel, #rightPanel, aside.right{ grid-column:1; grid-row:3; min-width: 0 !important; }
    }



/* --- layout patch v0.4.13 --- */
.rightCol{ grid-column:3; grid-row:1; min-width: 320px; }
@media (max-width: 980px){
  .rightCol{ grid-column:1; grid-row:3; min-width:0 !important; }
}

/* v0.4.14: remove residual ESC hint */
.mono.escHint{display:none!important;}

/* --- Store category tabs (v0.4.31 UI patch) --- */
.storeTabs{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-top:10px;
}
.storeTabs button{
  padding:6px 10px;
  border-radius:999px;
  font-size:12px;
  letter-spacing:.04em;
}
.storeTabs button.active{
  border-color:rgba(34,211,238,.55);
  color:var(--cyan);
  box-shadow:0 0 0 2px rgba(34,211,238,.10), 0 0 18px rgba(34,211,238,.10);
}

</style>
</head>
<body>
<div class="app">
<section class="panel">
<h2>HUD</h2>
<div class="row"><div class="k">Tick</div><div class="v mono" id="hudTick">0</div></div>
<div class="row"><div class="k">Mode</div><div class="v"><span class="pill cyan" id="hudMode">SELECT</span></div></div>
<div class="row"><div class="k">Selected</div><div class="v mono" id="hudSelected">None</div></div>
<div class="row"><div class="k">System</div><div class="v"><span class="pill bad" id="hudSystem">OFFLINE</span></div></div>
<div class="row"><div class="k">Phase</div><div class="v mono" id="hudPhase">PHASE 1</div></div>
<div class="row"><div class="k">Objective</div><div class="v mono" id="hudObjective">BOOT SEQUENCE</div></div>
<div class="row"><div class="k">Progress</div><div class="v mono" id="hudProgress">0 / 60</div></div>
<div class="row"><div class="k">Power</div><div class="v"><span class="pill bad" id="hudPowerState">RED</span> <span class="mono" id="hudPowerNums">(0.0 / 0.0)</span></div></div>
<div class="row"><div class="k">Population</div><div class="v mono" id="hudPop">0</div></div>
<div class="row"><div class="k">Happiness</div><div class="v"><span class="pill warn" id="hudHappyState">NEUTRAL</span> <span class="mono" id="hudHappy">50</span></div></div>
<div class="row"><div class="k">Money</div><div class="v mono" id="hudMoney">100.00</div></div>
<div class="row"><div class="k">Fuel</div><div class="v mono" id="hudFuel">0.800</div></div>
<div class="row"><div class="k">Food</div><div class="v mono" id="hudFood">6.000</div></div>
<div class="row"><div class="k">Water</div><div class="v mono" id="hudWater">6.000</div></div>
<div class="row"><div class="k">Life Support</div><div class="v"><span class="pill bad" id="hudLife">OFFLINE</span></div></div>
<div class="row" style="border-bottom:none;"><div class="k">Generator</div><div class="v"><span class="pill bad" id="hudGen">OFFLINE</span></div></div>
</section>
<section class="centerCol">
<div class="panel topbar">
<div class="brand">
<div class="title">Zone 13</div>
<div class="sub">v0.2.1 • Fuel production + population/taxes (fix standstill)</div>
<div class="confetti" id="confetti"></div>
</div>
<div class="tools">
<button id="btnStart">Start</button>
<button id="btnPause">Pause</button>
<button id="btnStep">Step Tick</button>
<button id="btnReset">Reset</button>
<span class="chip mono" style="opacity:.55;">DEV</span>
<button id="btnDev10" title="Fast-forward 10 ticks">+10</button>
<button id="btnDev100" title="Fast-forward 100 ticks">+100</button>
<input class="mono" id="devJump" min="0" placeholder="tick #" step="10" style="width:86px;padding:6px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.25);color:#d7e2ee;" type="number"/>
<button id="btnDevGo" title="Jump forward to tick #">GO</button>
<span class="chip mono">Milestone 2</span>
</div>
</div>
<section class="map panel" id="map">
<canvas id="c"></canvas>
<div class="phaseOverlay" id="phaseOverlay">
<div class="phaseTitle" id="phaseTitle">PHASE 1 — BOOT SEQUENCE</div>
<div class="phaseObj" id="phaseObj">Stabilize Power + Life for 60s</div>
<div class="phaseProg"><span id="phaseProg">0 / 60</span></div>
</div>
</section></section><section class="rightCol">
<div class="panel">
<div class="sectionTitle">
<h2 style="margin:0;">Store</h2>
<button id="btnStore" style="padding:6px 10px;">STORE</button>
</div>
<div class="box" id="storeBox" style="margin-top:8px;display:none;">
<div class="sectionTitle">
<div class="mono">Available</div>
<div style="font-size:12px;color:#b9c8d4;">Money: <span class="mono" id="storeMoney">100.00</span></div>
</div>
<div class="storeTabs" id="storeTabs"></div>
      <div id="storeContent"></div>
</div>
</div>
<div class="panel">
<div class="sectionTitle">
<h2 style="margin:0;">Inventory</h2>
<span class="chip mono" id="modeTag">SELECT</span>
</div>
<div class="box" style="margin-top:8px;">
<div style="font-size:12px;color:var(--muted);margin-bottom:8px;">Purchased items become placement tokens.</div>
<div id="invList"></div>
</div>
</div>
<div class="panel">
<div class="sectionTitle">
<h2 style="margin:0;">Selection</h2>
<span class="chip mono" id="selCoord">—</span>
</div>
<div class="box" style="margin-top:8px;">
<div class="mono" id="selName" style="font-size:13px;">Nothing selected</div>
<div id="selState" style="margin-top:8px;color:var(--muted);font-size:12px;">Click a building on the map.</div>
<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;">
<button disabled="" id="btnToggleOnline">Toggle</button>
<button disabled="" id="btnDelete">Remove</button>
<button disabled="" id="btnCancelPlace">Cancel Placement</button>
</div>
</div>
</div>
<div class="panel" style="display:flex;flex-direction:column;gap:10px;min-height:220px;">
<h2>Log</h2>
<div class="log" id="log"></div>
</div>
</section></div>





<script>

(() => {
  const MAP_COLS = 12, MAP_ROWS = 9;
  const TILE_W = 86, TILE_H = 44, BOARD_PAD_Y = 50;

  // Districts (visual overlay only for now; bonuses will hook in later)
  const DISTRICTS = [
    { id: "power", name: "Power District", color: "rgba(59,130,246,0.10)" },   // blue
    { id: "life",  name: "Life District",  color: "rgba(34,197,94,0.10)" },    // green
    { id: "prod",  name: "Production District", color: "rgba(245,158,11,0.10)" }, // amber
    { id: "civic", name: "Civic District", color: "rgba(168,85,247,0.10)" }    // purple
  ];

  function districtAt(gx, gy){
    const halfX = Math.floor(MAP_COLS/2);
    const halfY = Math.floor(MAP_ROWS/2);
    if (gx < halfX && gy < halfY) return "power";
    if (gx >= halfX && gy < halfY) return "life";
    if (gx < halfX && gy >= halfY) return "prod";
    return "civic";
  }

  function districtColor(id){
    const d = DISTRICTS.find(x => x.id === id);
    return d ? d.color : "rgba(255,255,255,0)";
  }

  function districtAt(gx, gy){
    const halfX = Math.floor(MAP_COLS/2);
    const halfY = Math.floor(MAP_ROWS/2);
    if (gx < halfX && gy < halfY) return "power";
    if (gx >= halfX && gy < halfY) return "life";
    if (gx < halfX && gy >= halfY) return "prod";
    return "civic";
  }

  function districtColor(id){
    const d = DISTRICTS.find(x => x.id === id);
    return d ? d.color : "rgba(255,255,255,0)";
  }

  // ECON tuning
  const START_MONEY = 100;
  const START_FUEL = 3.0;
  
  // ===== Progression Phases (v1, explicit) =====
  const PHASES = [
    { id:2, name:"BOOT SEQUENCE", objective:"Stabilize Power + Life", hold:60,
      ok: () => countOnline("generator")>0 && countOnline("life")>0 && state.fuel>0.0001 && (state.powerState==="STABLE" || state.powerState==="STRAINED")
    },
    { id:3, name:"CIVIL STABILIZATION", objective:"Reach Pop + Happiness", hold:30,
      ok: () => state.pop>=25 && state.happy>=85 && state.foodShortTicks===0 && state.waterShortTicks===0
    },
    { id:4, name:"INDUSTRIAL PRESSURE", objective:"Hold STABLE power at Pop 50", hold:45,
      ok: () => state.pop>=50 && state.powerState==="STABLE"
    },
    { id:5, name:"REACTOR TRANSITION", objective:"Bring Reactor ONLINE (replaces generators)", hold:1,
      ok: () => countOnline("reactor")>0 },
  ];

  function phaseSpec(){
    if(state.phase===1){
      const i = Math.min(state.directiveIndex||0, DIRECTIVES.length-1);
      const txt = (DIRECTIVES[i]&&DIRECTIVES[i].text) ? DIRECTIVES[i].text : "—";
      return { id:1, name:"ONBOARDING", objective:txt, hold:DIRECTIVES.length, isDirectives:true };
    }
    const found = PHASES.find(p=>p.id===state.phase);
    if(found) return found;
    // after last phase, stay at a "ZONE STABILIZED" state
    const last = PHASES[PHASES.length-1];
    return { id:last.id+1, name:"ZONE STABILIZED", objective:"Continue optimizing and expanding.", hold:1, ok:()=>true };
  }

  
  // Onboarding directives (Phase 1 uses these instead of a separate panel)
  const DIRECTIVES = [
    { id:"select", text:"Click a building to select it.", ok:()=>state.selectedKey!=null },
    { id:"toggle", text:"Toggle a building ONLINE.", ok:()=>anyOnline() },
    { id:"store", text:"Open the STORE.", ok:()=>state.storeOpenedOnce===true },
    { id:"fuel", text:"Buy and place a Fuel Station.", ok:()=>((state.builtCount.get("fuel")||0)>0) || (state.inventory.get("fuel")||0)>0 },
  ];
  function anyOnline(){ for(const b of state.buildings.values()){ if(b.online) return true; } return false; }
  function updateDirectives(){
    if(state.onboardingComplete) return;
    const i = state.directiveIndex||0;
    const d = DIRECTIVES[i];
    if(!d){ state.onboardingComplete=true; return; }
    if(d.ok()){
      state.directiveIndex = i+1;
      log(`DIRECTIVE COMPLETE — ${d.id.toUpperCase()}`);
      if(state.directiveIndex >= DIRECTIVES.length){
        state.onboardingComplete = true;
        state.phaseFlash = 180;
      }
    }
  }
function updatePhase(){
    if(state.phase===1){
      updateDirectives();
      // Phase 1 completes when onboarding directives are finished
      if(state.onboardingComplete){
        log(`PHASE 1 COMPLETE — ONBOARDING`);
        state.phase = 2;
        state.phaseHold = 0;
        state.phaseFlash = 180;
        state.celebrate = 60;
      }
      return;
    }

    const p = phaseSpec();
    if(state.celebrate===60) spawnConfetti();
    const ok = p.ok();
    if(ok) state.phaseHold = Math.min(p.hold, state.phaseHold + 1);
    else state.phaseHold = 0;

    if(state.phaseHold >= p.hold){
      log(`PHASE ${p.id} COMPLETE — ${p.name}`);
      const lastId = PHASES[PHASES.length-1].id;
      state.phase = Math.min(lastId+1, state.phase + 1);
      state.celebrate = 60;
      state.phaseHold = 0;
      state.phaseFlash = 180; // frames-ish (renderHUD uses it as countdown)
    }
    if(state.phaseFlash>0) state.phaseFlash--;
    if(state.celebrate>0) state.celebrate--;
  }

  // Global authorizations (dystopian system-wide upgrades)
  function mult(base, lvl, step){ return base * (1 + lvl*step); }
  function powerMult(){ return 1 + (state.upgrades.power * 0.25); }
  function fuelProdMult(){ return 1 + (state.upgrades.fuel * 0.25); }
  function foodProdMult(){ return 1 + (state.upgrades.food * 0.25); }
  function waterProdMult(){ return 1 + (state.upgrades.water * 0.25); }
  function housingMult(){ return 1 + (state.upgrades.housing * 0.50); } // reserved for capacity later

const FUEL_CAP = 5.0;
  const FUEL_PROD_PER_TICK = 0.06;
  const FUEL_DRAIN_PER_TICK = 0.06;
  const FOOD_CAP = 10.0, WATER_CAP = 10.0;
  const FOOD_PROD_PER_TICK = 0.04, WATER_PROD_PER_TICK = 0.04;

  // Consumption + scarcity
  const FOOD_CONS_PER_POP_PER_TICK = 0.002;
  const WATER_CONS_PER_POP_PER_TICK = 0.002;
  const SCARCITY_SUSTAIN_TICKS = 25; // ~25 seconds at 1 tick/sec
  const HAPPY_DOWN_SCARCITY = 0.08;
  const HAPPY_DOWN_SUSTAINED_SCARCITY = 0.18;

  // Population + taxes
  const POP_SEED = 12;
  const TAX_PER_PERSON_PER_TICK = 0.01;
  const POP_GROWTH_PER_TICK = 0.03;
  const POP_DECLINE_PER_TICK = 0.04;

  // Happiness
  const HAPPY_UP_STABLE = 0.08;
  const HAPPY_DOWN_UNSTABLE = 0.08;

  const CATALOG = {
  fuel: {type:"fuel",    name:"Fuel Station",   cost:30, oneOnly:false,  unlock: s => isLifeOnline(s)},
  generator: {type:"generator", name:"Generator", cost:50, oneOnly:false, unlock: s => true},
  food: {type:"food",    name:"Food Processor", cost:35, oneOnly:false,  unlock: s => isBuilt(s,"fuel")},
  water: {type:"water",   name:"Water Pump",     cost:40, oneOnly:false,  unlock: s => isBuilt(s,"food")},
  tech: {type:"tech",    name:"Tech Facility",  cost:60, oneOnly:true,  unlock: s => isBuilt(s,"fuel")},
  reactor: {type:"reactor", name:"Reactor Core",   cost:220, oneOnly:true,  w:2, h:2, unlock: s => s.phase>=5},
  housing: {type:"housing", name:"Housing Block",  cost:40, oneOnly:false, unlock: s => isSystemOnline(s)}
};

  // --- Store category tabs (UI-only; does not alter simulation) ---
  const STORE_TABS = ["BUILD","POWER","FUEL","FOOD","WATER","CIVIC"];

  // Which catalog items appear per tab
  const TAB_ITEMS = {
    BUILD: ["tech"],
    POWER: ["generator","reactor"],
    FUEL:  ["fuel"],
    FOOD:  ["food"],
    WATER: ["water"],
    CIVIC: ["housing"]
  };

  // Which global authorization appears per tab (one per tab)
  const TAB_AUTH_KEY = {
    POWER: "power",
    FUEL:  "fuel",
    FOOD:  "food",
    WATER: "water",
    CIVIC: "housing"
  };

  const state = {
    tick:0, running:false, timer:null,
    money:START_MONEY, fuel:START_FUEL, food:6.0, water:6.0,
    pop:0, happy:50,
    foodShortTicks:0, waterShortTicks:0,
    phase:1, phaseHold:0, phaseFlash:0,
    storeTab:"BUILD",
    tabHints:{BUILD:false,POWER:false,FUEL:false,FOOD:false,WATER:false,CIVIC:false},
    tabHintId:{BUILD:null,POWER:null,FUEL:null,FOOD:null,WATER:null,CIVIC:null},
    tabHintAck:{BUILD:null,POWER:null,FUEL:null,FOOD:null,WATER:null,CIVIC:null},
    directiveIndex:0, onboardingComplete:false,
    celebrate:0,
    powerSupply:0, powerDemand:0, powerState:"RED",
    buildings:new Map(), builtCount:new Map(),
    selectedKey:null, placingToken:null, hoverTile:null,
    inventory:new Map(),
    upgrades:{power:0,fuel:0,food:0,water:0,housing:0},
    storeOpenedOnce:false, storeNeedsNudge:false, popSeeded:false
  };

  const START_GEN = {x:4,y:3};
  const START_LIFE = {x:6,y:3};

  const el = {
    canvas: document.querySelector("#c"),
    map: document.querySelector("#map"),
    log: document.querySelector("#log"),
    hudTick: document.querySelector("#hudTick"),
    hudMode: document.querySelector("#hudMode"),
    hudSelected: document.querySelector("#hudSelected"),
    hudSystem: document.querySelector("#hudSystem"),
    hudPhase: document.querySelector("#hudPhase"),
    hudObjective: document.querySelector("#hudObjective"),
    hudProgress: document.querySelector("#hudProgress"),
    phaseTitle: document.querySelector("#phaseTitle"),
    phaseObj: document.querySelector("#phaseObj"),
    phaseProg: document.querySelector("#phaseProg"),
    hudPowerState: document.querySelector("#hudPowerState"),
    hudPowerNums: document.querySelector("#hudPowerNums"),
    hudPop: document.querySelector("#hudPop"),
    hudHappyState: document.querySelector("#hudHappyState"),
    hudHappy: document.querySelector("#hudHappy"),
    hudMoney: document.querySelector("#hudMoney"),
    hudFuel: document.querySelector("#hudFuel"),
    hudFood: document.querySelector("#hudFood"),
    hudWater: document.querySelector("#hudWater"),
    hudLife: document.querySelector("#hudLife"),
    hudGen: document.querySelector("#hudGen"),
    btnStart: document.querySelector("#btnStart"),
    btnPause: document.querySelector("#btnPause"),
    btnStep: document.querySelector("#btnStep"),
    btnReset: document.querySelector("#btnReset"),
    btnDev10: document.querySelector("#btnDev10"),
    btnDev100: document.querySelector("#btnDev100"),
    btnDevGo: document.querySelector("#btnDevGo"),
    devJump: document.querySelector("#devJump"),
    btnStore: document.querySelector("#btnStore"),
    storeBox: document.querySelector("#storeBox"),
    storeMoney: document.querySelector("#storeMoney"),
    storeTabs: document.querySelector("#storeTabs"),
    storeContent: document.querySelector("#storeContent"),
    invList: document.querySelector("#invList"),
    modeTag: document.querySelector("#modeTag"),
    selCoord: document.querySelector("#selCoord"),
    selName: document.querySelector("#selName"),
    selState: document.querySelector("#selState"),
    btnToggleOnline: document.querySelector("#btnToggleOnline"),
    btnDelete: document.querySelector("#btnDelete"),
    btnCancelPlace: document.querySelector("#btnCancelPlace"),
  };

  const ctx = el.canvas.getContext("2d");

// === Visual polish: Containment Platform in a Dead World (safe overlay) ===
// Purely visual: does not affect gameplay state, placement, or economy.
const _worldFx = (() => {
  const oc = document.createElement("canvas");
  oc.width = 256; oc.height = 256;
  const g = oc.getContext("2d");
  // Base dusty terrain
  g.fillStyle = "#14100c";
  g.fillRect(0,0,oc.width,oc.height);
  // Noise
  const img = g.getImageData(0,0,oc.width,oc.height);
  for(let i=0;i<img.data.length;i+=4){
    const n = (Math.random()*255)|0;
    const v = 14 + (n%24);
    img.data[i]   = v+6;  // r
    img.data[i+1] = v+3;  // g
    img.data[i+2] = v;    // b
    img.data[i+3] = 255;
  }
  g.putImageData(img,0,0);
  // Light dust streaks
  g.globalAlpha = 0.15;
  for(let i=0;i<18;i++){
    g.fillStyle = i%2 ? "#2a211a" : "#201813";
    const y = (Math.random()*256)|0;
    const h = 2 + ((Math.random()*6)|0);
    g.fillRect(0,y,256,h);
  }
  g.globalAlpha = 1;
  // Sparse grit specks
  g.globalAlpha = 0.25;
  for(let i=0;i<220;i++){
    g.fillStyle = (i%3===0) ? "#3a2f25" : "#221a14";
    const x = (Math.random()*256)|0;
    const y = (Math.random()*256)|0;
    g.fillRect(x,y,1,1);
  }
  g.globalAlpha = 1;

  return { patternCanvas: oc, pattern: null };
})();

function _ensureWorldPattern(){
  if(!_worldFx.pattern){
    _worldFx.pattern = ctx.createPattern(_worldFx.patternCanvas, "repeat");
  }
}

function drawWorld(origin, r){
  _ensureWorldPattern();

  // Terrain background
  ctx.globalAlpha = 1;
  ctx.fillStyle = _worldFx.pattern;
  ctx.fillRect(0,0,r.width,r.height);

  // Compute platform corners (slab under the map)
  const pad = 1.25;
  const A = tileToScreen(-pad, -pad);
  const B = tileToScreen(MAP_COLS+pad, -pad);
  const C = tileToScreen(MAP_COLS+pad, MAP_ROWS+pad);
  const D = tileToScreen(-pad, MAP_ROWS+pad);

  const ax = origin.x + A.x, ay = origin.y + A.y;
  const bx = origin.x + B.x, by = origin.y + B.y;
  const cx = origin.x + C.x, cy = origin.y + C.y;
  const dx = origin.x + D.x, dy = origin.y + D.y;

  // Drop shadow for depth (directional)
  ctx.save();
  ctx.globalAlpha = 0.55;
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.beginPath();
  ctx.moveTo(ax+18, ay+22);
  ctx.lineTo(bx+18, by+22);
  ctx.lineTo(cx+18, cy+22);
  ctx.lineTo(dx+18, dy+22);
  ctx.closePath();
  ctx.filter = "blur(14px)";
  ctx.fill();
  ctx.restore();

  // Slab fill (concrete/steel plate)
  const slabGrad = ctx.createLinearGradient(ax, ay, cx, cy);
  slabGrad.addColorStop(0, "rgba(28,30,33,0.96)");
  slabGrad.addColorStop(1, "rgba(18,20,23,0.96)");
  ctx.fillStyle = slabGrad;
  ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(bx, by);
  ctx.lineTo(cx, cy);
  ctx.lineTo(dx, dy);
  ctx.closePath();
  ctx.fill();

  // Edge highlight + wear
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(bx, by);
  ctx.lineTo(cx, cy);
  ctx.lineTo(dx, dy);
  ctx.closePath();
  ctx.stroke();

  // Subtle cracks/scratches on slab (procedural, cheap)
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  for(let i=0;i<26;i++){
    const t = i/26;
    const sx = ax*(1-t)+cx*t + (Math.random()*36-18);
    const sy = ay*(1-t)+cy*t + (Math.random()*26-13);
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(sx + (Math.random()*40-20), sy + (Math.random()*28-14));
    ctx.stroke();
  }
  ctx.restore();

  // Atmospheric vignette (keeps focus on the platform)
  const vg = ctx.createRadialGradient(r.width*0.5, r.height*0.55, Math.min(r.width,r.height)*0.15,
                                     r.width*0.5, r.height*0.55, Math.max(r.width,r.height)*0.75);
  vg.addColorStop(0, "rgba(0,0,0,0.00)");
  vg.addColorStop(1, "rgba(0,0,0,0.62)");
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,r.width,r.height);
}
// === End visual polish ===

  const keyOf = (x,y)=>`${x},${y}`;
  const clamp = (v,lo,hi)=>Math.max(lo,Math.min(hi,v));

  function log(msg){
    const t = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
    el.log.textContent += `[${t}] ${msg}\n`;
    el.log.scrollTop = el.log.scrollHeight;
  }

  function getB(x,y){
    const k=keyOf(x,y);
    const b=state.buildings.get(k);
    if(!b) return null;
    if(b.type==="occupy" && b.anchorKey) return state.buildings.get(b.anchorKey) || null;
    return b;
  }
  function setB(b){
    state.buildings.set(keyOf(b.x,b.y), b);
    state.builtCount.set(b.type, (state.builtCount.get(b.type)||0) + 1);
  }

  function setFootprintB(b){
    const w=b.w||1, h=b.h||1;
    const anchorKey = keyOf(b.x,b.y);
    // anchor
    const anchor = {...b, w, h, anchorKey};
    state.buildings.set(anchorKey, anchor);
    // mark occupied tiles
    for(let oy=0;oy<h;oy++) for(let ox=0;ox<w;ox++){
      if(ox===0 && oy===0) continue;
      const k=keyOf(b.x+ox, b.y+oy);
      state.buildings.set(k, {type:"occupy", x:b.x+ox, y:b.y+oy, anchorKey, anchorType:b.type});
    }
    // built count tracks anchors only
    state.builtCount.set(b.type, (state.builtCount.get(b.type)||0)+1);
  }

  function delB(x,y){
    const b = getB(x,y);
    if(!b) return;
    state.buildings.delete(keyOf(x,y));
    state.builtCount.set(b.type, Math.max(0,(state.builtCount.get(b.type)||1)-1));
  }
  function isBuilt(s,type){ return (s.builtCount.get(type)||0) > 0; }
  function isOwned(s,type){ return (s.builtCount.get(type)||0) > 0 || (s.inventory.get(type)||0) > 0; }
  function countOnline(type){
    let n=0;
    for(const b of state.buildings.values()) if(b.type===type && b.online) n++;
    return n;
  }
  function isGenOnline(){ return !!getB(START_GEN.x,START_GEN.y)?.online; }
  function isLifeOnline(){ return !!getB(START_LIFE.x,START_LIFE.y)?.online; }
  function isSystemOnline(){
  // System should be considered ONLINE when Life Support is ONLINE and at least one power source
  // (Generator OR Reactor) is ONLINE, and the grid is not in a RED (no-power) state.
  const hasPower = (countOnline("generator") > 0) || (countOnline("reactor") > 0);
  const hasLife  = countOnline("life") > 0;
  return hasPower && hasLife && state.powerState !== "RED";
}

  function tileToScreen(x,y){
    return {x:(x-y)*(TILE_W/2), y:(x+y)*(TILE_H/2)};
  }
  function screenToTile(px,py){
    const x = (px/(TILE_W/2) + py/(TILE_H/2)) / 2;
    const y = (py/(TILE_H/2) - px/(TILE_W/2)) / 2;
    return {x,y};
  }
  function boardOrigin(){
    const r = el.map.getBoundingClientRect();
    return {x:r.width/2, y:BOARD_PAD_Y};
  }
  function inBounds(x,y){ return x>=0 && y>=0 && x<MAP_COLS && y<MAP_ROWS; }

  function start(){
    if(state.running) return;
    state.running=true;
    state.timer=setInterval(tick, 1000);
    log("ENGINE start");
    renderAll();
  }
  function pause(){
    if(!state.running) return;
    state.running=false;
    clearInterval(state.timer);
    state.timer=null;
    log("ENGINE pause");
    renderAll();
  }
  function step(){ tick(); }

  function tick(){
    state.tick++;

    // Production (FIX: fuel now increases)
    const fOn = countOnline("fuel");
    const foodOn = countOnline("food");
    const waterOn = countOnline("water");

    if(fOn>0) state.fuel = Math.min(FUEL_CAP, state.fuel + (FUEL_PROD_PER_TICK*fOn*fuelProdMult()));
    if(foodOn>0) state.food = Math.min(FOOD_CAP, state.food + (FOOD_PROD_PER_TICK*foodOn*foodProdMult()));
    if(waterOn>0) state.water = Math.min(WATER_CAP, state.water + (WATER_PROD_PER_TICK*waterOn*waterProdMult()));

    
    // Consumption (population drives demand)
    const popNow = state.pop;
    let foodShort = false, waterShort = false;
    if(popNow > 0){
      const needFood = popNow * FOOD_CONS_PER_POP_PER_TICK;
      const needWater = popNow * WATER_CONS_PER_POP_PER_TICK;

      if(state.food + 1e-9 < needFood){ foodShort = true; state.food = 0; }
      else state.food = Math.max(0, state.food - needFood);

      if(state.water + 1e-9 < needWater){ waterShort = true; state.water = 0; }
      else state.water = Math.max(0, state.water - needWater);
    }

    // Scarcity counters (Stage 1 -> happiness pressure, Stage 2 -> population decline)
    if(foodShort) state.foodShortTicks++; else state.foodShortTicks = Math.max(0, state.foodShortTicks - 2);
    if(waterShort) state.waterShortTicks++; else state.waterShortTicks = Math.max(0, state.waterShortTicks - 2);
    const scarcitySustained = (state.foodShortTicks >= SCARCITY_SUSTAIN_TICKS) || (state.waterShortTicks >= SCARCITY_SUSTAIN_TICKS);

    // Power model (Phase 1 badge reads derived state; keep this core simple)
// - Supply: sum of ONLINE generators (requires fuel)
// - Demand: Life Support + (Phase 4) online producers/utility buildings that draw power
const GEN_OUTPUT = 1.6;
const REACTOR_OUTPUT = 5.2;
const LIFE_DEMAND = 1.0;

// Phase 4: power coupling (keep it light for early game; tune later)
const FUEL_DEMAND  = 0.05;  // fuel station/pump draw
const FOOD_DEMAND  = 0.25;  // food processor draw
const WATER_DEMAND = 0.25;  // water pump draw
const TECH_DEMAND  = 0.15;  // tech facility draw (if present)

const onlineGens = countOnline("generator");
const onlineReact = countOnline("reactor");
const onlineLife = countOnline("life");

const demandFuel = countOnline("fuel")  * FUEL_DEMAND;
const demandFood = countOnline("food")  * FOOD_DEMAND;
const demandWater= countOnline("water") * WATER_DEMAND;
const demandTech = countOnline("tech")  * TECH_DEMAND;

state.powerDemand = (onlineLife * LIFE_DEMAND) + demandFuel + demandFood + demandWater + demandTech;
    // If fuel is empty, generators cannot produce.
    state.powerSupply = (state.fuel > 0 ? (((onlineGens * GEN_OUTPUT) + (onlineReact * REACTOR_OUTPUT)) * powerMult()) : 0);

    // Canon badge states (OFFLINE / CRITICAL / STRAINED / STABLE)
    const sup = Number(state.powerSupply||0);
    const dem = Number(state.powerDemand||0);
    if(sup <= 0.000001) state.powerState = "OFFLINE";
    else if(dem <= 0.000001) state.powerState = "STABLE";
    else if(sup < dem) state.powerState = "CRITICAL";
    else {
      const buffer = 0.10 * dem;
      state.powerState = (sup < dem + buffer) ? "STRAINED" : "STABLE";
    }

    // Phase 2: Fuel Drain (authoritative)
    // - Any ONLINE generator consumes fuel continuously, even if nothing is drawing power yet.
    // - If fuel hits 0, generator is forced OFFLINE.

    // Drain fuel for ALL online generators.
    const gensOnlineNow = [];
    for(const b of state.buildings.values()){
      if(b.type === "generator" && b.online) gensOnlineNow.push(b);
    }
    if(gensOnlineNow.length){
      if(state.fuel > 0){
        const drain = (FUEL_DRAIN_PER_TICK * gensOnlineNow.length) * (1 + state.upgrades.power*0.10);
        state.fuel = Math.max(0, state.fuel - drain);
      }
      if(state.fuel === 0){
        for(const g of gensOnlineNow) g.online = false;
        log("Generators OFFLINE (fuel depleted)");
      }
    }

    // Happiness (scarcity affects happiness first; population reacts later)
    const stable = isSystemOnline();
    let happyDelta = (stable?HAPPY_UP_STABLE:-HAPPY_DOWN_UNSTABLE);
    if(foodShort || waterShort) happyDelta -= HAPPY_DOWN_SCARCITY;
    if(scarcitySustained) happyDelta -= HAPPY_DOWN_SUSTAINED_SCARCITY;
    state.happy = clamp(state.happy + happyDelta, 0, 100);
    const hs = state.happy>=70 ? "GREEN" : state.happy<=35 ? "RED" : "NEUTRAL";

    // Pop seed + dynamics (FIX: pop moves)
    if(stable && !state.popSeeded){
      state.pop = POP_SEED;
      state.popSeeded=true;
      log(`Population seeded: ${POP_SEED}`);
      if(!state.storeOpenedOnce) state.storeNeedsNudge=true;
    }
    if(stable && hs==="GREEN" && !scarcitySustained) state.pop += POP_GROWTH_PER_TICK;
    else if(!stable) state.pop -= POP_DECLINE_PER_TICK;
    else if(scarcitySustained && hs==="RED") state.pop -= POP_DECLINE_PER_TICK;
    state.pop = Math.max(0, state.pop);

    // Taxes (FIX: money keeps moving)
    if(stable && state.pop>0) state.money += state.pop * TAX_PER_PERSON_PER_TICK;

    // Store nudge
    if(isLifeOnline() && !state.storeOpenedOnce) state.storeNeedsNudge=true;

    if(!state.fastForward) renderAll();
  }

  function reset(){
    pause();
    state.tick=0;
    state.money=START_MONEY;
    state.fuel=START_FUEL;
    state.food=6.0;
    state.water=6.0;
    state.pop=0;
    state.happy=50;
    state.foodShortTicks=0; state.waterShortTicks=0;
    state.powerSupply=0; state.powerDemand=0; state.powerState="RED";

    state.buildings.clear();
    state.builtCount.clear();
    state.selectedKey=null;
    state.placingToken=null;
    state.hoverTile=null;
    state.inventory.clear();

    state.storeOpenedOnce=false;
    state.storeNeedsNudge=false;
    state.popSeeded=false;

    setB({type:"generator", name:"Generator", online:false, x:START_GEN.x, y:START_GEN.y});
    setB({type:"life", name:"Life Support", online:false, x:START_LIFE.x, y:START_LIFE.y});

    el.storeBox.style.display="none";
    el.btnStore.classList.remove("glowPulse");

    log("RESET complete");
    renderAll();
  }

  function toggleStore(){
    const open = el.storeBox.style.display!=="none";
    el.storeBox.style.display = open ? "none" : "block";
    if(!open){
      state.storeOpenedOnce=true;
      state.storeNeedsNudge=false;
      el.btnStore.classList.remove("glowPulse");
      log("STORE opened");
    } else log("STORE closed");
    renderStore();
  }

  function purchase(type){
    const item = CATALOG[type];
    if(!item) return;
    if(!item.unlock(state)){ log(`${item.name} is LOCKED.`); return; }
    if(item.oneOnly && isBuilt(state,type)){ log(`${item.name} already built.`); return; }
    if(state.money < item.cost){ log(`Insufficient funds for ${item.name}.`); return; }
    state.money -= item.cost;
    state.inventory.set(type, (state.inventory.get(type)||0)+1);
    log(`Purchased: ${item.name} (+1 token)`);
    beginTokenPlacement(type);
    renderAll();
  }

  function beginTokenPlacement(type){
    const item = CATALOG[type];
    if(!item) return;
    if((state.inventory.get(type)||0) <= 0){ log(`No ${item.name} tokens.`); return; }
    state.placingToken = {type, name:item.name};
    state.selectedKey = null;
    el.btnCancelPlace.disabled=false;
    log(`Placement mode: ${item.name}`);
    renderAll();
  }
  function cancelPlacement(){
    if(!state.placingToken) return;
    state.placingToken=null;
    el.btnCancelPlace.disabled=true;
    log("Placement cancelled (token kept).");
    renderAll();
  }

  function selectKey(k){
    state.selectedKey=k;
    state.placingToken=null;
    el.btnCancelPlace.disabled=true;
    renderAll();
  }
  function clearSelection(){ state.selectedKey=null; renderAll(); }

  function toggleSelectedOnline(){
  if(!state.selectedKey) return;
  const b = state.buildings.get(state.selectedKey);
  if(!b) return;
  b.online = !b.online;
  log((b.name||b.type)+" "+(b.online?"ONLINE":"OFFLINE"));
  renderAll();
}

function deleteSelected(){
    if(!state.selectedKey) return;
    const b = state.buildings.get(state.selectedKey);
    if(!b) return;
    if((b.x===START_GEN.x && b.y===START_GEN.y) || (b.x===START_LIFE.x && b.y===START_LIFE.y)){
      log("Cannot remove starter buildings in v0.2.1");
      return;
    }

    // Return building to inventory instead of deleting it forever.
    // This prevents new players from soft-locking themselves by experimenting with Remove.
    const type = b.type;
    const item = CATALOG[type];
    if(item){
      const cur = state.inventory.get(type)||0;
      if(item.oneOnly){
        // one-only items should never accumulate multiple tokens
        state.inventory.set(type, Math.min(1, cur + 1));
      } else {
        state.inventory.set(type, cur + 1);
      }
    }

    delB(b.x,b.y);
    log(`Removed to inventory: ${b.name}`);
    state.selectedKey=null;
    renderAll();
  }

  
  function spawnConfetti(){
    const box = document.getElementById("confetti");
    if(!box) return;
    box.innerHTML = "";
    const colors = ["#22c55e","#38bdf8","#f59e0b","#ef4444","#a78bfa","#eab308"];
    for(let i=0;i<18;i++){
      const el = document.createElement("i");
      el.style.left = (8 + Math.random()*84) + "%";
      el.style.top = (-10 - Math.random()*20) + "px";
      el.style.background = colors[(Math.random()*colors.length)|0];
      el.style.animationDelay = (Math.random()*120) + "ms";
      box.appendChild(el);
    }
  }
function renderHUD(){
    el.hudTick.textContent = String(state.tick);
    const mode = state.placingToken ? "PLACE" : "SELECT";
    el.hudMode.textContent = mode;
    el.modeTag.textContent = mode;

    const sel = state.selectedKey ? state.buildings.get(state.selectedKey) : null;
    el.hudSelected.textContent = sel ? `${sel.name} @ ${sel.x},${sel.y}` : "None";

    const sysOn = isSystemOnline();
    el.hudSystem.textContent = sysOn ? "ONLINE" : "OFFLINE";
    el.hudSystem.className = "pill " + (sysOn ? "good" : "bad");

    const p = phaseSpec();
    el.hudPhase.textContent = `PHASE ${p.id} — ${p.name}`;
    el.hudObjective.textContent = p.objective;
    el.hudProgress.textContent = `${state.phaseHold} / ${p.hold}`;
    if(el.phaseTitle){
      el.phaseTitle.textContent = `PHASE ${p.id} — ${p.name}`;
      // quest-style objective details
      let detail = p.objective;
      if(state.phase===1){
        const step = Math.min(state.directiveIndex||0, DIRECTIVES.length);
        const cur = Math.min(step+1, DIRECTIVES.length);
        detail = (DIRECTIVES[Math.min(step, DIRECTIVES.length-1)]?.text) || "—";
        el.phaseProg.textContent = `${cur} / ${DIRECTIVES.length}`;
      } else if(p.id===2){
        const g = countOnline("generator"), l = countOnline("life");
        detail = `Gen ${g}/${Math.max(1,g)} • Life ${l}/${Math.max(1,l)} • Fuel ${state.fuel.toFixed(2)}+ • Power ${state.powerState}`;
        el.phaseProg.textContent = `${state.phaseHold} / ${p.hold}`;
      } else if(p.id===3){
        detail = `Pop ${Math.floor(state.pop)}/25 • Happy ${Math.floor(state.happy)}/85 • Shortages ${(state.foodShortTicks||0)+(state.waterShortTicks||0)===0 ? "0" : "!"}`;
        el.phaseProg.textContent = `${state.phaseHold} / ${p.hold}`;
      } else if(p.id===4){
        detail = `Pop ${Math.floor(state.pop)}/50 • Power ${state.powerState} (need STABLE)`;
        el.phaseProg.textContent = `${state.phaseHold} / ${p.hold}`;
      } else {
        el.phaseProg.textContent = `${state.phaseHold} / ${p.hold}`;
      }
      el.phaseObj.textContent = detail;

      // glow when metrics are met and we're holding
      let okNow = false;
      if(state.phase===1){
        okNow = state.onboardingComplete===true;
      } else {
        okNow = !!p.ok();
      }
      const po = document.getElementById("phaseOverlay");
      if(po){
        po.classList.toggle("phaseReady", okNow && state.phaseHold>0);
        po.classList.toggle("celebrate", state.celebrate>0);
      }
    }
    if(state.phaseFlash>0){
      el.hudPhase.style.color = "var(--good)";
    } else {
      el.hudPhase.style.color = "";
    }


    el.hudPowerState.textContent = state.powerState;
    el.hudPowerState.className = "pill " + (state.powerState==="STABLE" ? "good" : state.powerState==="STRAINED" ? "warn" : "bad");
    el.hudPowerNums.textContent = `(${state.powerSupply.toFixed(1)} / ${state.powerDemand.toFixed(1)})`;

    el.hudPop.textContent = String(Math.floor(state.pop));
    const hs = state.happy>=70 ? "GREEN" : state.happy<=35 ? "RED" : "NEUTRAL";
    el.hudHappyState.textContent = hs;
    el.hudHappyState.className = "pill " + (hs==="GREEN" ? "good" : hs==="RED" ? "bad" : "warn");
    el.hudHappy.textContent = String(Math.round(state.happy));

    el.hudMoney.textContent = state.money.toFixed(2);
    el.storeMoney.textContent = state.money.toFixed(2);

    el.hudFuel.textContent = state.fuel.toFixed(3);
    el.hudFood.textContent = state.food.toFixed(3);
    el.hudWater.textContent = state.water.toFixed(3);

    const genCount = countOnline("generator");
    const life = getB(START_LIFE.x,START_LIFE.y);
    el.hudGen.textContent = genCount>0 ? `ONLINE (${genCount})` : "OFFLINE";
    el.hudGen.className = "pill " + (genCount>0 ? "good" : "bad");
    el.hudLife.textContent = life?.online ? "ONLINE" : "OFFLINE";
    el.hudLife.className = "pill " + (life?.online ? "good" : "bad");

    if(state.storeNeedsNudge) el.btnStore.classList.add("glowPulse");
  }

  function storeHint(type, locked, placed, owned){
    if(placed) return "Already built."; 
    if(owned) return "Owned. Place from inventory.";
    if(locked){
      if(type==="fuel") return "Unlock: Life Support ONLINE.";
      if(type==="food") return "Unlock: Fuel Station built.";
      if(type==="water") return "Unlock: Food Processor built.";
      if(type==="tech") return "Unlock: Fuel Station built.";
      if(type==="housing") return "Unlock: System ONLINE.";
      return "Locked.";
    }
    if(type==="housing") return "Repeatable. Raises capacity later.";
    if(type==="tech") return "One-only. Generates tech points later.";
    if(type==="fuel") return "Produces fuel while ONLINE.";
    if(type==="food") return "Produces food while ONLINE.";
    if(type==="water") return "Produces water while ONLINE.";
    return "Purchase creates a placement token.";
  }

  function renderStore(){
    // Store can be rendered even while closed; keep it safe.
    if(!el.storeContent || !el.storeTabs) return;

    renderStoreTabs();

    const tab = (state.storeTab || "BUILD");
    el.storeContent.innerHTML = "";

    // Authorization section (one per tab where applicable)
    const authKey = TAB_AUTH_KEY[tab];
    if(authKey){
      const title = document.createElement("div");
      title.className = "subTitle";
      title.textContent = "AUTHORIZATIONS";
      el.storeContent.appendChild(title);
      renderAuthKey(el.storeContent, authKey);
    }

    // Procurement section (catalog items)
    const items = TAB_ITEMS[tab] || [];
    if(items.length){
      const title2 = document.createElement("div");
      title2.className = "subTitle";
      title2.style.marginTop = authKey ? "10px" : "0";
      title2.textContent = "PROCUREMENT";
      el.storeContent.appendChild(title2);

      for(const type of items){
        const item = CATALOG[type];
        if(!item) continue;
        renderCatalogItem(el.storeContent, item);
      }
    } else if(!authKey){
      const d = document.createElement("div");
      d.style.color = "var(--muted)";
      d.style.fontSize = "12px";
      d.style.marginTop = "10px";
      d.textContent = "No items in this category yet.";
      el.storeContent.appendChild(d);
    }
  }

  function renderStoreTabs(){
    const tab = (state.storeTab || "BUILD");
    el.storeTabs.innerHTML = "";
    for(const t of STORE_TABS){
      const btn = document.createElement("button");
      const hintOn = !!(state.tabHints && state.tabHints[t]);
      // Active tab gets "active"; hint glow is reserved for actionable nudges.
      btn.className = (t===tab ? "active" : "") + (hintOn ? " glowPulse" : "");
      btn.textContent = t;
      btn.addEventListener("click", ()=>{
        state.storeTab = t;
        // Acknowledge the current hint for this tab (so it stops glowing).
        if(state.tabHintId && state.tabHintId[t]){
          state.tabHintAck[t] = state.tabHintId[t];
        }
        if(state.tabHints) state.tabHints[t] = false;
        renderStore();
      });
      el.storeTabs.appendChild(btn);
    }
  }

  function updateTabHints(){
    // Hints are soft nudges toward the next optimal move.
    // They do NOT change simulation math; UI signal only.
    const sysOn = isSystemOnline();
    const capFood = (typeof FOOD_CAP !== "undefined") ? FOOD_CAP : 10.0;
    const capWater = (typeof WATER_CAP !== "undefined") ? WATER_CAP : 10.0;

    // Helper: set a hint id for a tab; glow appears only if not yet acknowledged.
    function setHint(tab, hintId){
      state.tabHintId[tab] = hintId || null;
      state.tabHints[tab] = !!(hintId && state.tabHintAck[tab] !== hintId);
    }

    // Default: clear all hint ids, then re-apply with priority.
    for(const t of STORE_TABS){
      state.tabHintId[t] = null;
      state.tabHints[t] = false;
    }

    // ===== Priority 1: Newly unlocked authorizations =====
    // Encourage the player to notice new tools when phases unlock them.
    if(upgradeUnlocked("power") && (state.upgrades.power||0)===0) setHint("POWER","auth_unlock_power");
    if(upgradeUnlocked("fuel")  && (state.upgrades.fuel||0)===0)  setHint("FUEL","auth_unlock_fuel");
    if(upgradeUnlocked("food")  && (state.upgrades.food||0)===0)  setHint("FOOD","auth_unlock_food");
    if(upgradeUnlocked("water") && (state.upgrades.water||0)===0) setHint("WATER","auth_unlock_water");
    if(upgradeUnlocked("housing") && (state.upgrades.housing||0)===0) setHint("CIVIC","auth_unlock_civic");

    // ===== Priority 2: Pre-emptive stability nudges (only when system is online) =====
    if(sysOn){
      // Power margin approaching strain (avoid panic glow when already critical/offline).
      if(state.powerDemand > 0.0001 && (state.powerState==="STABLE" || state.powerState==="STRAINED")){
        const marginRatio = state.powerSupply / Math.max(0.0001, state.powerDemand);
        if(marginRatio < 1.15) setHint("POWER","near_strain");
      }

      // Resource margins (nudge before sustained scarcity).
      if(state.pop > 0){
        if(state.food < capFood*0.20 && state.foodShortTicks < 3) setHint("FOOD","food_low");
        if(state.water < capWater*0.20 && state.waterShortTicks < 3) setHint("WATER","water_low");
      }

      // Civic scaling: if stable + happy, but no housing built yet, nudge CIVIC.
      const hasHousing = (state.builtCount.get("housing")||0) > 0;
      const happyGreen = state.happy >= 70;
      if(happyGreen && !hasHousing && state.pop >= 18) setHint("CIVIC","scale_housing");
    }

    // Active tab should never glow (avoid self-spotlight).
    const active = state.storeTab || "BUILD";
    state.tabHints[active] = false;
  }


  function renderCatalogItem(container, item){
    const locked = !item.unlock(state);
    const placed = item.oneOnly && isBuilt(state,item.type);
    const owned = item.oneOnly && isOwned(state,item.type);
    const canBuy = !locked && !owned && state.money>=item.cost;

    const div = document.createElement("div");
    div.className="item";

    const left = document.createElement("div");
    left.innerHTML = `<div class="itemTitle">${item.name}</div><div class="itemMeta">${storeHint(item.type,locked,placed,owned)}</div>`;

    const right = document.createElement("div");
    right.className="itemRight";

    const tag = document.createElement("div");
    tag.className="tag " + (placed ? "built" : locked ? "locked" : owned ? "owned" : "");
    tag.textContent = placed ? "BUILT" : locked ? "LOCKED" : owned ? "OWNED" : "AVAILABLE";

    const cost = document.createElement("div");
    cost.className="mono"; cost.style.fontSize="12px";
    cost.textContent = `Cost: ${item.cost}`;

    const btn = document.createElement("button");
    btn.textContent = owned ? "Owned" : "Buy";
    btn.disabled = owned || locked || !canBuy;
    btn.addEventListener("click", ()=>purchase(item.type));

    right.appendChild(tag); right.appendChild(cost); right.appendChild(btn);
    div.appendChild(left); div.appendChild(right);
    container.appendChild(div);
  }

  function upgradeCost(key){
    const lvl = state.upgrades[key]||0;
    const base = {power:120,fuel:100,food:110,water:110,housing:140}[key] || 120;
    return Math.floor(base * Math.pow(1.65, lvl));
  }
  function upgradeLabel(key){
    const lvl = state.upgrades[key]||0;
    const eff = key==="housing" ? (1 + lvl*0.50) : (1 + lvl*0.25);
    const pct = Math.round((eff-1)*100);
    const name = {power:"GRID OUTPUT", fuel:"FUEL YIELD", food:"NUTRITION PROTOCOL", water:"WATER PROTOCOL", housing:"DENSITY POLICY"}[key] || key.toUpperCase();
    return {name, lvl, pct};
  }
  function upgradeUnlocked(key){
    if(key==="power") return state.phase>=2;
    if(key==="fuel") return state.phase>=3;
    if(key==="food") return state.phase>=4;
    if(key==="water") return state.phase>=4;
    if(key==="housing") return state.phase>=4;
    return false;
  }
  function buyUpgrade(key){
    if(!upgradeUnlocked(key)){ log("Authorization locked by phase."); return; }
    const cost = upgradeCost(key);
    if(state.money < cost){ log("Insufficient funds for authorization."); return; }
    state.money -= cost;
    state.upgrades[key] = (state.upgrades[key]||0) + 1;
    log(`Authorization updated: ${key.toUpperCase()} → L${state.upgrades[key]}`);
    renderAll();
  }
  function renderAuth(){
    // Back-compat: render the currently relevant tab authorization(s) into the content panel.
    if(!el.storeContent) return;
    const tab = (state.storeTab || "BUILD");
    const authKey = TAB_AUTH_KEY[tab];
    if(authKey){
      renderAuthKey(el.storeContent, authKey);
    }
  }

  function renderAuthKey(container, key){
    const u = upgradeLabel(key);
    const locked = !upgradeUnlocked(key);
    const cost = upgradeCost(key);

    const row = document.createElement("div");
    row.className="item";

    const left = document.createElement("div");
    left.innerHTML = `<div class="itemTitle">${u.name}</div><div class="itemMeta">Level ${u.lvl} (+${u.pct}%)</div>`;

    const right = document.createElement("div");
    right.className="itemRight";

    const tag = document.createElement("div");
    tag.className="tag " + (locked ? "locked" : "");
    tag.textContent = locked ? "LOCKED" : "ACTIVE";

    const c = document.createElement("div");
    c.className="mono"; c.style.fontSize="12px";
    c.textContent = `Cost: ${cost}`;

    const btn = document.createElement("button");
    btn.textContent = "Authorize";
    btn.disabled = locked || state.money < cost;
    btn.addEventListener("click", ()=>buyUpgrade(key));

    right.appendChild(tag); right.appendChild(c); right.appendChild(btn);
    row.appendChild(left); row.appendChild(right);
    container.appendChild(row);
  }

  function renderInventory(){
    el.invList.innerHTML="";
    const keys = [...state.inventory.keys()];
    if(keys.length===0){
      const d=document.createElement("div");
      d.style.color="var(--muted)"; d.style.fontSize="12px";
      d.textContent="No tokens yet. Buy something in the store.";
      el.invList.appendChild(d);
      return;
    }
    for(const type of keys){
      const count = state.inventory.get(type)||0;
      if(count<=0) continue;
      const item = CATALOG[type];

      const row=document.createElement("div");
      row.className="invRow";

      const left=document.createElement("div");
      left.innerHTML = `<div class="invName">${item.name}</div><div class="invCount">Tokens: <span class="mono">${count}</span></div>`;

      const btn=document.createElement("button");
      btn.textContent="Place";
      btn.addEventListener("click", ()=>beginTokenPlacement(type));

      row.appendChild(left); row.appendChild(btn);
      el.invList.appendChild(row);
    }
  }

  function renderSelectionPanel(){
    const sel = state.selectedKey ? state.buildings.get(state.selectedKey) : null;
    if(!sel){
      el.selCoord.textContent="—";
      el.selName.textContent="Nothing selected";
      el.selState.textContent = state.placingToken ? `Placing: ${state.placingToken.name}. Click an empty tile.` : "Click a building on the map.";
      el.btnToggleOnline.disabled=true;
    el.btnToggleOnline.textContent="Toggle ONLINE";
      el.btnDelete.disabled=true;
      el.btnCancelPlace.disabled=!state.placingToken;
      return;
    }
    el.selCoord.textContent = `${sel.x},${sel.y}`;
    el.selName.textContent = sel.name;
    el.selState.innerHTML = `<div style="font-size:12px;color:var(--muted);line-height:1.4;">
      Type: <span class="mono">${sel.type}</span><br/>
      Status: <span class="mono">${sel.online ? "ONLINE":"OFFLINE"}</span></div>`;
    el.btnToggleOnline.disabled=false;
        el.btnToggleOnline.textContent = sel.online ? "Toggle OFFLINE" : "Toggle ONLINE";
el.btnDelete.disabled=false;
  }

  function renderAll(){
    updatePhase();
    updateTabHints();
    renderHUD();
    renderStore();
    renderInventory();
    renderSelectionPanel();
    draw();
  }

  function resizeCanvas(){
    const r = el.map.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    el.canvas.width = Math.floor(r.width*dpr);
    el.canvas.height = Math.floor(r.height*dpr);
    el.canvas.style.width = r.width+"px";
    el.canvas.style.height = r.height+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resizeCanvas);

  function draw(){
    const r = el.map.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);
    const origin = boardOrigin();

    drawWorld(origin, r);

    for(let y=0;y<MAP_ROWS;y++) for(let x=0;x<MAP_COLS;x++) drawTile(x,y,origin);

    const arr=[...state.buildings.values()].filter(b=>b.type!=="occupy").sort((a,b)=>(a.x+a.y)-(b.x+b.y));
    for(const b of arr) drawBuilding(b,origin);

    drawConnections(origin);

    if(state.placingToken && state.hoverTile){
      const {x,y}=state.hoverTile;
      const item = CATALOG[state.placingToken.type];
      const w=item.w||1, h=item.h||1;
      let ok=true;
      for(let oy=0;oy<h;oy++) for(let ox=0;ox<w;ox++){
        const tx=x+ox, ty=y+oy;
        if(!inBounds(tx,ty) || state.buildings.get(keyOf(tx,ty))) ok=false;
      }
      if(ok) drawGhost(x,y,origin,w,h);
    }

    if(state.selectedKey){
      const b = state.buildings.get(state.selectedKey);
      if(b) drawSelectRing(b.x,b.y,origin);
    }
  }

  // --- Visual animation loop (independent of simulation ticks) ---
  // Simulation advances on state.tick (1 Hz). Visuals animate smoothly using state.anim (~60 FPS).
  state.anim = 0;
  state._lastAnim = null;
  function visualLoop(now){
    if(state._lastAnim===null) state._lastAnim = now;
    const dt = Math.min(0.05, (now - state._lastAnim)/1000);
    state._lastAnim = now;
    state.anim += dt * 60; // visual "ticks"
    draw();
    requestAnimationFrame(visualLoop);
  }
  requestAnimationFrame(visualLoop);

  function drawConnections(origin){
    // Show thin power routing hints.
    // Visible when hovering a generator OR when the grid is strained/overloaded.
    let show = false;
    if(state.hoverTile){
      const hb = getB(state.hoverTile.x, state.hoverTile.y);
      if(hb && hb.type==="generator") show = true;
    }
    if(state.powerState!=="STABLE") show = true;
    if(!show) return;

    const gens = [...state.buildings.values()].filter(b=>b.type==="generator");
    if(!gens.length) return;

    const powered = [...state.buildings.values()].filter(b=>b.type!=="generator" && b.online);
    if(!powered.length) return;

    // Visual intensity by state
    const a = (state.powerState==="OVERLOAD") ? 0.28 : (state.powerState==="STRAINED") ? 0.18 : 0.12;
    const wob = (state.powerState==="OVERLOAD") ? 1.5 : (state.powerState==="STRAINED") ? 0.9 : 0.0;

    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    // Draw one connection per powered building to its nearest generator (reduces clutter)
    for(const b of powered){
      let best = gens[0], bestD = 1e9;
      for(const g of gens){
        const d = Math.abs(g.x-b.x)+Math.abs(g.y-b.y);
        if(d < bestD){ bestD = d; best = g; }
      }

      const gp = tileToScreen(best.x, best.y);
      const bp = tileToScreen(b.x, b.y);
      const x1 = origin.x + gp.x;
      const y1 = origin.y + gp.y - 18;
      const x2 = origin.x + bp.x;
      const y2 = origin.y + bp.y - 18;

      // subtle animated variance so lines feel "alive" but not flashy
      const t = state.anim*0.03 + (b.x*13 + b.y*7)*0.01;
      const jx = (Math.sin(t)*wob);
      const jy = (Math.cos(t*1.3)*wob);

      // Under-glow stroke
      ctx.globalAlpha = a*0.9;
      ctx.lineWidth = 3;
      ctx.strokeStyle = "rgba(34,211,238,0.85)";
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2 + jx, y2 + jy);
      ctx.stroke();

      // Core stroke
      ctx.globalAlpha = a;
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(214,222,230,0.75)";
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2 + jx, y2 + jy);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawTile(x,y,origin){
    const p = tileToScreen(x,y);
    const cx = origin.x + p.x;
    const cy = origin.y + p.y;

    const hover = state.hoverTile && state.hoverTile.x===x && state.hoverTile.y===y;
    const occupied = !!getB(x,y);
    const fill = occupied ? "rgba(10,16,21,.90)" : "rgba(9,14,19,.85)";
    const stroke = hover ? "rgba(34,211,238,.55)" : "rgba(255,255,255,.10)";

    ctx.beginPath();
    ctx.moveTo(cx, cy - TILE_H/2);
    ctx.lineTo(cx + TILE_W/2, cy);
    ctx.lineTo(cx, cy + TILE_H/2);
    ctx.lineTo(cx - TILE_W/2, cy);
    ctx.closePath();

    // District tint underlay (keeps the original look, but hints planning zones)
    const dcol = districtColor(districtAt(x,y));
    if(!occupied){ ctx.fillStyle=dcol; ctx.fill(); }

    ctx.fillStyle=fill; ctx.globalAlpha = occupied ? 1.0 : 0.90; ctx.fill();
    ctx.globalAlpha = 1.0;
    ctx.lineWidth=1; ctx.strokeStyle=stroke; ctx.stroke();
  }

  function roundRect(x,y,w,h,r,fill,stroke,fillStyle,strokeStyle){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    if(fill){ ctx.fillStyle=fillStyle||"rgba(9,16,22,.9)"; ctx.fill(); }
    if(stroke){ ctx.strokeStyle=strokeStyle||"rgba(255,255,255,.10)"; ctx.stroke(); }
  }

  function shortLabel(type){
    switch(type){
      case "generator": return "GENERATOR";
      case "life": return "LIFE SUPPORT";
      case "fuel": return "FUEL";
      case "food": return "FOOD";
      case "water": return "WATER";
      case "tech": return "TECH";
      case "housing": return "HOUSING";
      default: return "UNIT";
    }
  }

  function iconForType(type){
    switch(type){
      case "generator": return "⚡";
      case "life": return "⛑";
      case "fuel": return "⛽";
      case "food": return "⬢";
      case "water": return "💧";
      case "tech": return "⌬";
      case "housing": return "▦";
      default: return "■";
    }
  }

  function iconColor(type, online){
    // Placeholder palette: muted when offline, slightly themed per system when online.
    if(!online) return "rgba(214,222,230,.35)";
    switch(type){
      case "generator": return "rgba(34,197,94,.95)";      // green
      case "life": return "rgba(34,211,238,.92)";          // cyan
      case "fuel": return "rgba(234,179,8,.92)";           // amber
      case "water": return "rgba(96,165,250,.92)";         // blue-ish
      case "food": return "rgba(163,230,53,.92)";          // lime
      case "tech": return "rgba(217,70,239,.85)";          // magenta
      case "housing": return "rgba(248,113,113,.85)";      // soft red
      default: return "rgba(214,222,230,.70)";
    }
  }


  function powerPulseState(){
    // Canon pulse states (v1.1): STABLE (green/calm), STRAINED (amber), CRITICAL (red/rapid), OFFLINE (dim)
    // Purely visual: derived from existing supply/demand if full word state isn't present.
    const sup = Number(state.powerSupply||0);
    const dem = Number(state.powerDemand||0);
    if(state.powerState) return state.powerState; // if engine provides it, use it
    if(sup<=0.000001) return "OFFLINE";
    if(dem<=0.000001) return "STABLE";
    if(sup < dem) return "CRITICAL";
    const buffer = 0.10 * dem;
    if(sup < dem + buffer) return "STRAINED";
    return "STABLE";
  }

  function drawPowerBadge(cx, topY, isOnline){
    // Large industrial badge above generator card. Purely visual.
    const mode = powerPulseState();
    const online = !!isOnline;
    const r = 18;
    const bx = cx;
    const by = topY - 18;

    // Pulse speeds (per tick) and base alpha
    let speed = 0.04, baseA = 0.75;
    let col = "rgba(214,222,230,.35)";
    if(online){
      if(mode==="STABLE"){ col="rgba(34,197,94,.95)"; speed=0.025; baseA=0.75; }
      if(mode==="STRAINED"){ col="rgba(234,179,8,.92)"; speed=0.018; baseA=0.68; }
      if(mode==="CRITICAL"){ col="rgba(239,68,68,.92)"; speed=0.06; baseA=0.70; }
    }
    const pulse = online ? (baseA + (Math.sin(state.tick*speed)*0.18)) : 0.25;

    ctx.save();
    // Outer glow
    if(online){
      ctx.globalAlpha = Math.max(0, Math.min(1, pulse));
      ctx.beginPath();
      ctx.arc(bx, by, r+8, 0, Math.PI*2);
      ctx.fillStyle = col;
      ctx.filter = "blur(10px)";
      ctx.fill();
      ctx.filter = "none";
    }

    // Plate
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(bx, by, r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(9,16,22,.94)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.stroke();

    // Bolt rivets
    const riv = 2.2;
    for(const a of [0, Math.PI/2, Math.PI, 3*Math.PI/2]){
      const rx = bx + Math.cos(a)*(r-5);
      const ry = by + Math.sin(a)*(r-5);
      ctx.beginPath();
      ctx.arc(rx, ry, riv, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,.18)";
      ctx.fill();
    }

    // Lightning glyph
    ctx.globalAlpha = online ? 1 : 0.55;
    ctx.fillStyle = col;
    ctx.font = "18px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("⚡", bx, by+0.5);

    // Small mode dot (diagnostic)
    let dot = "rgba(214,222,230,.35)";
    if(online){
      if(mode==="STABLE") dot="rgba(34,197,94,.95)";
      if(mode==="STRAINED") dot="rgba(234,179,8,.92)";
      if(mode==="CRITICAL") dot="rgba(239,68,68,.92)";
    }
    ctx.globalAlpha = online ? 0.95 : 0.35;
    ctx.beginPath();
    ctx.arc(bx + r - 4, by + r - 4, 3.2, 0, Math.PI*2);
    ctx.fillStyle = dot;
    ctx.fill();

    ctx.restore();
  }

  
  function drawTypeBadge(kind, cx, topY, isOnline){
    const online = !!isOnline;
    const r = 16;
    const bx = cx;
    const by = topY - 18;

    // Color per kind (high contrast, matches silhouettes)
    const colors = {
      power: ["rgba(255,90,90,0.95)","rgba(255,200,140,0.95)"],
      fuel:  ["rgba(255,210,70,0.95)","rgba(255,140,40,0.95)"],
      life:  ["rgba(80,220,255,0.95)","rgba(200,255,255,0.95)"],
      food:  ["rgba(34,197,94,0.95)","rgba(170,255,190,0.95)"],
      water: ["rgba(59,130,246,0.95)","rgba(200,235,255,0.95)"],
      tech:  ["rgba(168,85,247,0.95)","rgba(235,215,255,0.95)"],
      house: ["rgba(245,245,245,0.85)","rgba(255,255,255,0.95)"]
    };
    const pal = colors[kind] || ["rgba(214,222,230,.55)","rgba(255,255,255,0.85)"];
    const col = pal[0];
    const icon = pal[1];

    const speed = (kind==="power") ? 0.03 : 0.06;
    const baseA = online ? 0.72 : 0.25;
    const pulse = online ? (baseA + (Math.sin(state.tick*speed)*0.18)) : baseA;

    ctx.save();

    // Outer glow
    if(online){
      ctx.globalAlpha = Math.max(0, Math.min(1, pulse));
      ctx.beginPath();
      ctx.arc(bx, by, r+7, 0, Math.PI*2);
      ctx.fillStyle = col;
      ctx.fill();
    }

    // Badge body
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(bx, by, r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(10,12,14,0.86)";
    ctx.fill();

    // Ring
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = online ? col : "rgba(214,222,230,.35)";
    ctx.stroke();

    // Icon drawing
    ctx.fillStyle = icon;
    ctx.strokeStyle = icon;
    ctx.lineWidth = 2;

    if(kind==="fuel" || kind==="water"){
      // Droplet
      ctx.beginPath();
      ctx.moveTo(bx, by-9);
      ctx.bezierCurveTo(bx+7, by-2, bx+6, by+6, bx, by+9);
      ctx.bezierCurveTo(bx-6, by+6, bx-7, by-2, bx, by-9);
      ctx.closePath();
      ctx.fill();
      // inner highlight for fuel
      if(kind==="fuel"){
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.moveTo(bx+2, by-6);
        ctx.bezierCurveTo(bx+5, by-1, bx+4, by+3, bx+1, by+6);
        ctx.bezierCurveTo(bx+2, by+2, bx+2, by, bx+2, by-6);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    } else if(kind==="food"){
      // Leaf
      ctx.beginPath();
      ctx.ellipse(bx, by+1, 8, 10, -0.6, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(bx-3, by+6);
      ctx.lineTo(bx+6, by-6);
      ctx.stroke();
    } else if(kind==="life"){
      // Medical cross
      ctx.fillRect(bx-3, by-9, 6, 18);
      ctx.fillRect(bx-9, by-3, 18, 6);
    } else if(kind==="tech"){
      // Chip
      ctx.beginPath();
      ctx.rect(bx-7, by-7, 14, 14);
      ctx.stroke();
      // pins
      for(let i=-6;i<=6;i+=4){
        ctx.beginPath(); ctx.moveTo(bx+i, by-10); ctx.lineTo(bx+i, by-8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bx+i, by+10); ctx.lineTo(bx+i, by+8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bx-10, by+i); ctx.lineTo(bx-8, by+i); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bx+10, by+i); ctx.lineTo(bx+8, by+i); ctx.stroke();
      }
    } else if(kind==="house"){
      // Home
      ctx.beginPath();
      ctx.moveTo(bx-9, by+2);
      ctx.lineTo(bx, by-8);
      ctx.lineTo(bx+9, by+2);
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      ctx.rect(bx-6, by+2, 12, 9);
      ctx.stroke();
      ctx.beginPath();
      ctx.rect(bx-2, by+6, 4, 5);
      ctx.fill();
    } else {
      // Fallback dot
      ctx.beginPath(); ctx.arc(bx, by, 4, 0, Math.PI*2); ctx.fill();
    }

    ctx.restore();
  }

function drawBuilding(b,origin){
    const p=tileToScreen(b.x,b.y);
    const cx=origin.x+p.x, cy=origin.y+p.y;

    const vt = (state.anim!=null ? state.anim : vt);

    // Small helper: soft halo so buildings pop on the muted slab
    function halo(color, alphaBase, speed){
      if(!b.online) return;
      ctx.save();
      const pulse = 0.65 + 0.25*Math.sin(vt*(speed||0.06));
      ctx.globalAlpha = alphaBase + pulse*alphaBase;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(cx, cy-6, 30, 14, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Small helper: crisp outline
    function outlineRect(x,y,w,h,stroke){
      ctx.save();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.strokeRect(x,y,w,h);
      ctx.restore();
    }

    // Common label style
    function smallTag(text, x, y){
      ctx.save();
      ctx.fillStyle="rgba(10,12,14,0.65)";
      roundRect(x-16, y-9, 32, 18, 8, true, false, null, null);
      ctx.fillStyle="rgba(255,255,255,0.92)";
      ctx.font="10px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(text, x, y+0.5);
      ctx.restore();
    }

    // === On-map status glyphs (minimal, readable) ===
    function alertBadge(x,y,txt,color){
      ctx.save();
      ctx.globalAlpha = 0.95;
      // plate
      ctx.beginPath();
      ctx.arc(x,y,10,0,Math.PI*2);
      ctx.fillStyle = "rgba(9,16,22,.96)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = color;
      ctx.stroke();
      // symbol
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.font = "12px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
      ctx.textAlign = "center"; ctx.textBaseline = "middle";
      ctx.fillText(txt, x, y+0.5);
      ctx.restore();
    }

    function drawStatusGlyphs(){
      const alerts = [];
      // Power/offline
      if(!b.online) alerts.push({t:"⚡", c:"rgba(255,90,90,0.95)"});
      // Fuel empty warning (generators + fuel station)
      if((state.fuel!=null && state.fuel <= 0.01) && (b.type==="generator" || b.type==="fuel")){
        alerts.push({t:"F", c:"rgba(234,179,8,0.95)"});
      }
      // Food/Water shortages (global) - show on relevant chain buildings
      if(state.foodShortTicks!=null && state.foodShortTicks>0 && (b.type==="food" || b.type==="housing" || b.type==="life")){
        alerts.push({t:"FO", c:"rgba(34,197,94,0.95)"});
      }
      if(state.waterShortTicks!=null && state.waterShortTicks>0 && (b.type==="water" || b.type==="housing" || b.type==="life")){
        alerts.push({t:"W", c:"rgba(59,130,246,0.95)"});
      }
      // Low happiness
      if(state.happy!=null && state.happy<=25 && (b.type==="housing" || b.type==="life")){
        alerts.push({t:"!", c:"rgba(245,158,11,0.95)"});
      }
      if(!alerts.length) return;

      const y = topY - 16; // above the building
      const spacing = 22;
      const startX = cx - ((alerts.length-1)*spacing)/2;
      for(let i=0;i<alerts.length;i++){
        const a = alerts[i];
        alertBadge(startX + i*spacing, y, a.t, a.c);
      }
    }

    const topY = cy-36;

    // === GENERATOR: bright industrial red (visibility-first) ===
    if(b.type==="generator"){
      const _t=vt;
      const _drift = b.online ? (Math.sin(_t*0.06+0.0)*1.1) : 0;
      ctx.save();
      ctx.translate(0, _drift);
      const GEN_GLOW = "rgba(255,70,70,1)";
      const GEN_BASE = "rgba(140,25,25,0.98)";
      const GEN_BODY = "rgba(220,55,55,0.96)";
      const GEN_VENT = "rgba(95,15,15,1)";
      const GEN_RIB  = "rgba(255,255,255,0.12)";
      const GEN_PANEL_ON  = "rgba(255,210,90,1)";
      const GEN_PANEL_OFF = "rgba(255,255,255,0.25)";

      halo(GEN_GLOW, 0.24, 0.05);

      // drop shadow
      ctx.save(); ctx.globalAlpha=0.38; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // base + body
      ctx.fillStyle=GEN_BASE; ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(255,90,90,0.55)");

      ctx.fillStyle=GEN_BODY; ctx.fillRect(cx-14, cy-40, 28, 26);
      outlineRect(cx-14, cy-40, 28, 26, "rgba(255,120,120,0.6)");

      // ribs
      ctx.strokeStyle=GEN_RIB; ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(cx-7, cy-40); ctx.lineTo(cx-7, cy-14);
      ctx.moveTo(cx+7, cy-40); ctx.lineTo(cx+7, cy-14);
      ctx.stroke();

      // vent stack
      ctx.fillStyle=GEN_VENT; ctx.fillRect(cx-4, cy-52, 8, 12);

      // panel glow
      ctx.save();
      ctx.globalAlpha = b.online ? (0.85 + 0.25*Math.sin(vt*0.06)) : 1.0;
      ctx.fillStyle = b.online ? GEN_PANEL_ON : GEN_PANEL_OFF;
      ctx.fillRect(cx-4, cy-32, 8, 8);
      ctx.restore();

      // tiny fan (micro motion)
      if(b.online){
        ctx.save();
        ctx.translate(cx, cy-46);
        ctx.rotate(vt*0.05);
        ctx.globalAlpha=0.75;
        ctx.strokeStyle="rgba(255,230,170,0.9)";
        ctx.lineWidth=1.5;
        ctx.beginPath();
        ctx.moveTo(-5,0); ctx.lineTo(5,0);
        ctx.moveTo(0,-5); ctx.lineTo(0,5);
        ctx.stroke();
        ctx.restore();
      }

      smallTag("GEN", cx, cy-6);
      drawPowerBadge(cx, topY-18, b.online);
      ctx.restore();
      return;
    }

    // === FUEL STATION: caution-amber, high contrast ===
    if(b.type==="fuel"){
      const _t=vt;
      const _drift = b.online ? (Math.sin(_t*0.05+1.2)*0.9) : 0;
      ctx.save();
      ctx.translate(0, _drift);
      const FUEL_GLOW = "rgba(255,210,70,1)";
      const FUEL_BASE = "rgba(80,55,15,0.98)";
      const FUEL_TANK = "rgba(255,200,60,0.98)";      // brighter!
      const FUEL_TANK2= "rgba(255,230,130,0.95)";
      const FUEL_PIPE = "rgba(35,24,8,1)";
      const STRIPE    = "rgba(20,14,6,0.85)";

      halo(FUEL_GLOW, 0.24, 0.06);

      // shadow
      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // base
      ctx.fillStyle=FUEL_BASE; ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(255,210,70,0.55)");

      // tank block
      ctx.fillStyle=FUEL_TANK; ctx.fillRect(cx-14, cy-42, 28, 28);
      outlineRect(cx-14, cy-42, 28, 28, "rgba(255,240,160,0.65)");

      // caution stripes
      ctx.save();
      ctx.strokeStyle=STRIPE; ctx.lineWidth=3;
      for(let i=-18;i<=18;i+=8){
        ctx.beginPath();
        ctx.moveTo(cx-14+i, cy-42);
        ctx.lineTo(cx-14+i+14, cy-14);
        ctx.stroke();
      }
      ctx.restore();

      // highlight cap
      ctx.fillStyle=FUEL_TANK2;
      ctx.fillRect(cx-10, cy-38, 20, 6);

      // pipe/nozzle
      ctx.fillStyle=FUEL_PIPE;
      ctx.fillRect(cx+10, cy-26, 10, 5);
      ctx.fillRect(cx+18, cy-28, 4, 10);

      // indicator lamp
      ctx.save();
      ctx.globalAlpha = b.online ? (0.85 + 0.25*Math.sin(vt*0.07)) : 0.35;
      ctx.fillStyle = "rgba(255,120,30,1)";
      ctx.beginPath(); ctx.arc(cx-10, cy-26, 3.5, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // subtle exhaust puff (mechanical, not noisy)
      if(b.online){
        ctx.save();
        const u = (_t*0.02)%1;                 // 0..1
        const rise = 18*u;
        ctx.globalAlpha = 0.30*(1-u);
        ctx.fillStyle = "rgba(255,240,200,0.9)";
        ctx.beginPath(); ctx.arc(cx+18, cy-34-rise, 3.8+2.6*u, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 0.20*(1-u);
        ctx.beginPath(); ctx.arc(cx+14, cy-30-rise*0.8, 2.8+2.0*u, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }


      smallTag("FUEL", cx, cy-6);
      drawTypeBadge("fuel", cx, topY-18, b.online);
      ctx.restore();
      return;
    }

    // === LIFE SUPPORT: cool-cyan facility ===
    if(b.type==="life"){
      const _t=vt;
      const _drift = b.online ? (Math.sin(_t*0.04+2.1)*0.75) : 0;
      ctx.save();
      ctx.translate(0, _drift);
      const C="rgba(80,220,255,1)";
      halo(C, 0.22, 0.055);

      // subtle dome pulse
      if(b.online){
        ctx.save();
        const k = 0.65 + 0.25*Math.sin(_t*0.035);
        ctx.globalAlpha = 0.30*k;
        ctx.fillStyle = "rgba(80,220,255,1)";
        ctx.beginPath();
        ctx.ellipse(cx, cy-46, 18*k, 10*k, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }


      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // base
      ctx.fillStyle="rgba(18,28,34,0.98)";
      ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(120,240,255,0.45)");

      // dome
      ctx.fillStyle="rgba(40,160,190,0.95)";
      ctx.beginPath(); ctx.arc(cx, cy-30, 14, Math.PI, 0); ctx.closePath(); ctx.fill();
      ctx.strokeStyle="rgba(200,250,255,0.35)"; ctx.lineWidth=2; ctx.stroke();

      // panel
      ctx.save();
      ctx.globalAlpha = b.online ? (0.75 + 0.18*Math.sin(vt*0.06)) : 0.35;
      ctx.fillStyle="rgba(190,255,255,0.95)";
      ctx.fillRect(cx-4, cy-20, 8, 6);
      ctx.restore();

      smallTag("LIFE", cx, cy-6);
      drawTypeBadge("life", cx, topY-18, b.online);
      ctx.restore();
      return;
    }

    // === FOOD: vivid green processor ===
    if(b.type==="food"){
      const _t=vt;
      const _drift = b.online ? (Math.sin(_t*0.05+3.0)*0.75) : 0;
      ctx.save();
      ctx.translate(0, _drift);
      const C="rgba(110,255,110,1)";
      halo(C, 0.22, 0.06);

      // subtle grow-light shimmer
      if(b.online){
        ctx.save();
        const k = 0.7 + 0.2*Math.sin(_t*0.045);
        ctx.globalAlpha = 0.26*k;
        ctx.fillStyle = "rgba(34,197,94,1)";
        ctx.beginPath();
        ctx.ellipse(cx, cy-30, 22, 10, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }


      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.fillStyle="rgba(16,26,18,0.98)";
      ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(140,255,140,0.45)");

      ctx.fillStyle="rgba(70,180,90,0.95)";
      ctx.fillRect(cx-14, cy-42, 28, 28);
      outlineRect(cx-14, cy-42, 28, 28, "rgba(200,255,200,0.35)");

      // indicator
      ctx.save();
      ctx.globalAlpha = b.online ? (0.75 + 0.2*Math.sin(vt*0.065)) : 0.35;
      ctx.fillStyle="rgba(220,255,220,0.95)";
      ctx.beginPath(); ctx.arc(cx, cy-28, 4, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      smallTag("FOOD", cx, cy-6);
      drawTypeBadge("food", cx, topY-18, b.online);
      ctx.restore();
      return;
    }

    // === WATER: bright blue pump ===
    if(b.type==="water"){
      const _t=vt;
      const _drift = b.online ? (Math.sin(_t*0.05+4.0)*0.75) : 0;
      ctx.save();
      ctx.translate(0, _drift);
      const C="rgba(90,170,255,1)";
      halo(C, 0.22, 0.06);

      // subtle ripple tick
      if(b.online){
        ctx.save();
        const s = Math.sin(_t*0.06);
        ctx.globalAlpha = 0.38;
        ctx.strokeStyle = "rgba(200,235,255,0.95)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy-34, 10+2*s, 0.2*Math.PI, 0.8*Math.PI);
        ctx.stroke();
        ctx.restore();
      }


      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.fillStyle="rgba(14,22,30,0.98)";
      ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(120,200,255,0.45)");

      ctx.fillStyle="rgba(60,120,190,0.95)";
      ctx.fillRect(cx-14, cy-40, 28, 26);
      outlineRect(cx-14, cy-40, 28, 26, "rgba(200,230,255,0.35)");

      // small tower
      ctx.fillStyle="rgba(40,90,140,1)";
      ctx.fillRect(cx-3, cy-52, 6, 12);

      // droplet lamp
      ctx.save();
      ctx.globalAlpha = b.online ? (0.85 + 0.25*Math.sin(vt*0.07)) : 0.35;
      ctx.fillStyle="rgba(210,240,255,0.95)";
      ctx.beginPath();
      ctx.moveTo(cx, cy-30);
      ctx.quadraticCurveTo(cx+6, cy-22, cx, cy-18);
      ctx.quadraticCurveTo(cx-6, cy-22, cx, cy-30);
      ctx.fill();
      ctx.restore();

      smallTag("WATR", cx, cy-6);
      drawTypeBadge("water", cx, topY-18, b.online);
      ctx.restore();
      return;
    }

    // === TECH: purple comms node ===
    
    if(b.type==="reactor"){
      const _t=vt;
      const _drift = b.online ? (Math.sin(_t*0.05+1.3)*0.9) : 0;
      ctx.save();
      ctx.translate(0,_drift);

      const R_GLOW = "rgba(255,210,90,1)";
      const R_PLATE= "rgba(210,140,40,0.95)";
      const R_BODY = "rgba(255,180,60,0.92)";
      const R_DARK = "rgba(90,55,18,1)";
      const R_EDGE = "rgba(255,235,170,0.40)";

      // footprint plate (2x2)
      const p2 = tileToScreen(b.x+1, b.y+1);
      const fx = origin.x+p2.x, fy = origin.y+p2.y;
      // halo
      halo(R_GLOW, 0.18, 0.045);

      // base shadow
      ctx.save(); ctx.globalAlpha=0.35; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(fx, fy-10, 60, 24, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // main plate
      ctx.fillStyle=R_PLATE;
      ctx.beginPath();
      ctx.moveTo(fx, fy-54);
      ctx.lineTo(fx+70, fy-18);
      ctx.lineTo(fx, fy+18);
      ctx.lineTo(fx-70, fy-18);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle=R_EDGE; ctx.lineWidth=2; ctx.stroke();

      // reactor body
      ctx.fillStyle=R_BODY;
      ctx.fillRect(fx-26, fy-46, 52, 48);
      outlineRect(fx-26, fy-46, 52, 48, "rgba(255,235,170,0.55)");

      // core window
      ctx.fillStyle=R_DARK;
      ctx.fillRect(fx-10, fy-34, 20, 26);
      if(b.online){
        ctx.save(); ctx.globalAlpha=0.75;
        ctx.fillStyle="rgba(255,245,210,0.55)";
        ctx.fillRect(fx-8, fy-32, 16, 22);
        ctx.restore();
      }

      // tag
      smallTag("R", fx, fy-54);

      // alerts
      if(!b.online) alertBadge(fx+44, fy-40, "OFF", "rgba(255,255,255,0.85)");
      ctx.restore();
      return;
    }

if(b.type==="tech"){
      const _t=vt;
      const _drift = b.online ? (Math.sin(_t*0.045+5.1)*0.7) : 0;
      ctx.save();
      ctx.translate(0, _drift);
      const C="rgba(200,120,255,1)";
      halo(C, 0.20, 0.055);

      // subtle status blink
      if(b.online){
        ctx.save();
        ctx.globalAlpha = 0.70 + 0.30*Math.sin(_t*0.09);
        ctx.fillStyle = "rgba(235,215,255,0.95)";
        ctx.fillRect(cx-2, cy-44, 4, 4);
        ctx.restore();
      }


      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.fillStyle="rgba(22,18,30,0.98)";
      ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(220,170,255,0.45)");

      ctx.fillStyle="rgba(120,70,170,0.95)";
      ctx.fillRect(cx-14, cy-40, 28, 26);
      outlineRect(cx-14, cy-40, 28, 26, "rgba(240,220,255,0.35)");

      // antenna
      ctx.strokeStyle="rgba(240,220,255,0.75)";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(cx, cy-52); ctx.lineTo(cx, cy-40);
      ctx.stroke();

      smallTag("TECH", cx, cy-6);
      drawTypeBadge("tech", cx, topY-18, b.online);
      ctx.restore();
      return;
    }

    // === HOUSING: warm modular habitat (visibility-first) ===
    if(b.type==="house" || b.type==="housing"){
      const _t=vt;
      const _drift = b.online ? (Math.sin(_t*0.04+6.0)*0.75) : 0;
      ctx.save();
      ctx.translate(0, _drift);

      const H_GLOW = "rgba(255,210,120,1)";     // warm human presence
      const H_BASE = "rgba(70,55,35,0.98)";     // dark foundation
      const H_BODY1= "rgba(210,155,70,0.96)";   // main module
      const H_BODY2= "rgba(240,185,90,0.96)";   // upper module
      const H_EDGE = "rgba(255,230,170,0.55)";
      const H_WIN  = "rgba(255,220,140,1)";
      const H_WIN_OFF="rgba(25,30,36,0.85)";

      halo(H_GLOW, 0.18, 0.045);

      // shadow
      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 24, 11, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // slab base
      ctx.fillStyle=H_BASE;
      ctx.fillRect(cx-19, cy-14, 38, 16);
      outlineRect(cx-19, cy-14, 38, 16, "rgba(255,220,140,0.22)");

      // lower module (slightly wider)
      ctx.fillStyle=H_BODY1;
      ctx.fillRect(cx-16, cy-44, 32, 30);
      outlineRect(cx-16, cy-44, 32, 30, H_EDGE);

      // upper module (offset, implies stacked prefab)
      ctx.fillStyle=H_BODY2;
      ctx.fillRect(cx-14, cy-66, 28, 22);
      outlineRect(cx-14, cy-66, 28, 22, "rgba(255,245,200,0.55)");

      // antenna / vent
      ctx.strokeStyle="rgba(255,230,170,0.55)";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(cx+10, cy-66);
      ctx.lineTo(cx+10, cy-78);
      ctx.stroke();

      // windows (pulse when online)
      const wPulse = b.online ? (0.70 + 0.30*Math.sin(_t*0.06)) : 0.0;
      ctx.save();
      ctx.globalAlpha = b.online ? (0.65 + 0.35*wPulse) : 1.0;
      ctx.fillStyle = b.online ? H_WIN : H_WIN_OFF;

      // lower module windows
      ctx.fillRect(cx-11, cy-36, 6, 6);
      ctx.fillRect(cx-2,  cy-36, 6, 6);
      ctx.fillRect(cx+7,  cy-36, 6, 6);

      // upper module windows
      ctx.fillRect(cx-9,  cy-58, 5, 5);
      ctx.fillRect(cx-1,  cy-58, 5, 5);
      ctx.fillRect(cx+7,  cy-58, 5, 5);

      ctx.restore();

      smallTag("HOME", cx, cy-6);
      drawTypeBadge((b.type==="housing"?"house":b.type), cx, topY-18, b.online);
      ctx.restore();
      return;
    }

    // Fallback: keep existing card
    const w=64,h=38;
    roundRect(cx-gw/2, topY, gw, gh, 10, true, true, "rgba(9,16,22,.92)", "rgba(255,255,255,.18)");

    ctx.fillStyle = b.online ? "rgba(255,255,255,.95)" : "rgba(214,222,230,.90)";
    ctx.font="11px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(shortLabel(b.type), cx, topY+14);

    ctx.fillStyle="rgba(214,222,230,.70)";
    ctx.font="10px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.fillText(b.online?"ONLINE":"OFFLINE", cx, topY+28);

    // Status glyphs (only when something needs attention)
    drawStatusGlyphs();

  }


  function drawGhost(x,y,origin,w=1,h=1){
    const p=tileToScreen(x,y);
    // FOOTPRINT OUTLINE

    const cx=origin.x+p.x, cy=origin.y+p.y;
    const gw=64,gh=38; const topY=cy-36;

    ctx.save();
    ctx.globalAlpha=0.55;
    roundRect(cx-gw/2, topY, gw, gh, 10, true, true, "rgba(34,211,238,.10)", "rgba(34,211,238,.55)");
    ctx.fillStyle="rgba(34,211,238,.85)";
    ctx.font="10px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText("PLACE", cx, topY+gh/2);
    ctx.restore();
  }

  function drawSelectRing(x,y,origin){
    const p=tileToScreen(x,y);
    const cx=origin.x+p.x, cy=origin.y+p.y;
    ctx.save();
    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(34,211,238,.75)";
    ctx.beginPath();
    ctx.moveTo(cx, cy - TILE_H/2 + 2);
    ctx.lineTo(cx + TILE_W/2 - 2, cy);
    ctx.lineTo(cx, cy + TILE_H/2 - 2);
    ctx.lineTo(cx - TILE_W/2 + 2, cy);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  // Inputs
  el.btnStart.addEventListener("click", start);
  el.btnPause.addEventListener("click", pause);
  el.btnStep.addEventListener("click", step);
  el.btnReset.addEventListener("click", reset);
  // DEV fast-forward helpers (for testing)
  function devFastForward(n){
    // pause engine to avoid race with interval
    if(state.running) pause();
    state.fastForward = true;
    for(let i=0;i<n;i++) tick();
    state.fastForward = false;
    renderAll();
    log(`DEV fast-forward +${n} ticks`);
  }
  function devJumpTo(target){
    if(state.running) pause();
    target = Math.max(0, Math.floor(target||0));
    if(target <= state.tick){ renderAll(); return; }
    const n = target - state.tick;
    devFastForward(n);
  }
  if(el.btnDev10) el.btnDev10.addEventListener("click", ()=>devFastForward(10));
  if(el.btnDev100) el.btnDev100.addEventListener("click", ()=>devFastForward(100));
  if(el.btnDevGo) el.btnDevGo.addEventListener("click", ()=>{
    const v = el.devJump ? parseInt(el.devJump.value||"0",10) : 0;
    devJumpTo(v);
  });

  el.btnStore.addEventListener("click", toggleStore);
  el.btnToggleOnline.addEventListener("click", toggleSelectedOnline);
  el.btnDelete.addEventListener("click", deleteSelected);
  el.btnCancelPlace.addEventListener("click", cancelPlacement);
  window.addEventListener("keydown",(e)=>{ if(e.key==="Escape") cancelPlacement(); });
function canvasPoint(e){
    const r=el.canvas.getBoundingClientRect();
    return {x:e.clientX-r.left, y:e.clientY-r.top};
  }
  function pickTile(px,py){
    const origin=boardOrigin();
    const bx=px-origin.x, by=py-origin.y;
    const raw=screenToTile(bx,by);
    const tx=Math.floor(raw.x+0.5), ty=Math.floor(raw.y+0.5);
    if(!inBounds(tx,ty)) return null;

    // Primary hit test: standard diamond.
    const center=tileToScreen(tx,ty);
    const cx=origin.x+center.x, cy=origin.y+center.y;
    const dx=Math.abs(px-cx)/(TILE_W/2);
    const dy=Math.abs(py-cy)/(TILE_H/2);
    if(dx+dy<=1.05) return {x:tx,y:ty};

    // Fallback: if we're near an edge/corner, try the 4 cardinal neighbor tiles
    // and take the closest diamond. This makes selecting multi-tile buildings
    // (like the 2x2 reactor) feel much less "pixel perfect".
    let best=null;
    const candidates=[
      {x:tx,y:ty},
      {x:tx+1,y:ty},
      {x:tx-1,y:ty},
      {x:tx,y:ty+1},
      {x:tx,y:ty-1},
    ];
    for(const c of candidates){
      if(!inBounds(c.x,c.y)) continue;
      const cc=tileToScreen(c.x,c.y);
      const ccx=origin.x+cc.x, ccy=origin.y+cc.y;
      const cdx=Math.abs(px-ccx)/(TILE_W/2);
      const cdy=Math.abs(py-ccy)/(TILE_H/2);
      const score=cdx+cdy;
      if(score<=1.18 && (!best || score<best.score)) best={x:c.x,y:c.y,score};
    }
    return best ? {x:best.x,y:best.y} : null;
  }

  el.canvas.addEventListener("mousemove",(e)=>{
    const pt=canvasPoint(e);
    state.hoverTile = pickTile(pt.x,pt.y);
    draw();
  });
  el.canvas.addEventListener("mouseleave",()=>{ state.hoverTile=null; draw(); });

  el.canvas.addEventListener("click",(e)=>{
    const pt=canvasPoint(e);
    const tile=pickTile(pt.x,pt.y);
    if(!tile) return;
    let k=keyOf(tile.x,tile.y);
    let b=state.buildings.get(k);
    if(b && b.type==="occupy" && b.anchorKey){
      k = b.anchorKey;
      b = state.buildings.get(k);
    }

    if(state.placingToken){
      const type=state.placingToken.type;
      const item=CATALOG[type];
      const w=item.w||1, h=item.h||1;
      // footprint availability check
      for(let oy=0;oy<h;oy++) for(let ox=0;ox<w;ox++){
        const tx=tile.x+ox, ty=tile.y+oy;
        if(!inBounds(tx,ty) || state.buildings.get(keyOf(tx,ty))){ log("Footprint blocked. Choose a clear area."); return; }
      }

      if(item.oneOnly && isBuilt(state,type)){ log(`${item.name} is one-only and already built.`); state.placingToken=null; renderAll(); return; }

      const count=state.inventory.get(type)||0;
      if(count<=0){ log(`No ${item.name} tokens to place.`); state.placingToken=null; renderAll(); return; }
      state.inventory.set(type, count-1);

      // Reactor canon: placing it replaces existing generators (returned to inventory)
      if(type==="reactor"){
        let removed=0;
        for(const [kk,v] of [...state.buildings.entries()]){
          if(v.type==="generator"){
            state.buildings.delete(kk);
            removed++;
            state.inventory.set("generator",(state.inventory.get("generator")||0)+1);
          }
          if(v.type==="occupy" && v.anchorType==="generator") state.buildings.delete(kk);
        }
        if(removed>0) log(`Reactor installed: ${removed} generator(s) returned to inventory.`);
      }

      setFootprintB({type, name:item.name, online:false, x:tile.x, y:tile.y, w:(item.w||1), h:(item.h||1)});
      log(`Placed: ${item.name} @ ${tile.x},${tile.y} (OFFLINE)`);

      state.placingToken=null;
      renderAll();
      return;
    }

    if(b) selectKey(k);
    else clearSelection();
  });

  // Init
  function init(){
    reset();
    resizeCanvas();
    log("Loaded v0.2.1 (fuel + pop + taxes fix).");
    renderAll();
  }
  init();
})();

</script>
</body>
</html>
