<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Zone 13 | v0.2.7f Phase 4 Power Coupling</title>
  <style>
    :root{
      --bg:#070b0e; --panel:#0d141a; --panel2:#0a1015; --border:#1b2a33;
      --ink:#d6dee6; --muted:#8ea0ad;
      --good:#22c55e; --warn:#eab308; --bad:#ef4444; --cyan:#22d3ee;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    .app{height:100%;display:grid;grid-template-columns:380px 1fr 420px;gap:12px;padding:12px;}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;box-shadow:var(--shadow);padding:12px;overflow:hidden;}
    .panel h2{margin:0 0 10px 0;font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:var(--muted);}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;font-variant-numeric:tabular-nums;}
    .row{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:7px 0;border-bottom:1px solid rgba(255,255,255,.06);}
    .row:last-child{border-bottom:none;}
    .k{font-size:12px;color:var(--muted);}
    .v{font-size:13px;}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:2px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);font-size:12px;}
    .pill.good{color:var(--good);border-color:rgba(34,197,94,.35);}
    .pill.warn{color:var(--warn);border-color:rgba(234,179,8,.35);}
    .pill.bad{color:var(--bad);border-color:rgba(239,68,68,.35);}
    .pill.cyan{color:var(--cyan);border-color:rgba(34,211,238,.35);}
    button{background:#0a1116;border:1px solid var(--border);color:var(--ink);
      padding:8px 10px;border-radius:10px;cursor:pointer;font-size:13px;}
    button:hover{border-color:rgba(34,211,238,.45);color:var(--cyan);}
    button[disabled]{opacity:.45;cursor:not-allowed;}
    .glowPulse{
      animation: pulse 1.4s ease-in-out infinite;
      border-color: rgba(34,211,238,.55) !important;
      box-shadow: 0 0 0 2px rgba(34,211,238,.10), 0 0 22px rgba(34,211,238,.25);
      color: var(--cyan) !important;
    }
    @keyframes pulse{
      0%{ box-shadow: 0 0 0 2px rgba(34,211,238,.06), 0 0 18px rgba(34,211,238,.12); }
      50%{ box-shadow: 0 0 0 2px rgba(34,211,238,.14), 0 0 30px rgba(34,211,238,.28); }
      100%{ box-shadow: 0 0 0 2px rgba(34,211,238,.06), 0 0 18px rgba(34,211,238,.12); }
    }

    .topbar{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;}
    .brand{display:flex;flex-direction:column;gap:2px;}
    .brand .title{font-size:13px;letter-spacing:.08em;text-transform:uppercase;color:#b9c8d4;}
    .brand .sub{font-size:12px;color:var(--muted);}
    .tools{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end;}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:999px;border:1px solid var(--border);background:var(--panel2);font-size:12px;color:#cfe0ee;}
    .mapPanel{display:grid;grid-template-rows:auto 1fr;gap:12px;min-width:0;}
    .map{background:linear-gradient(180deg, rgba(34,211,238,.04), rgba(0,0,0,0));
      border:1px solid var(--border);border-radius:14px;position:relative;overflow:hidden;
      display:flex;align-items:center;justify-content:center;min-height:560px;}
    canvas{display:block; width:100%; height:100%;}
    .overlayHint{
      position:absolute; left:14px; top:14px;
      padding:8px 10px; border-radius:12px;
      background:rgba(9,16,22,.80); border:1px solid rgba(255,255,255,.10);
      font-size:12px; color:#cfe0ee;
    }
    .overlayHint b{color:var(--cyan); font-weight:600;}
    .rightCol{display:flex;flex-direction:column;gap:12px;min-width:0;}

    .box{background:var(--panel2);border:1px solid var(--border);border-radius:12px;padding:10px;}
    .sectionTitle{display:flex;align-items:center;justify-content:space-between;gap:10px;}

    .item{background:#070c10;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px;
      display:flex;align-items:flex-start;justify-content:space-between;gap:12px;margin-top:8px;}
    .itemTitle{font-size:13px;}
    .itemMeta{font-size:12px;color:var(--muted);margin-top:4px;line-height:1.35;}
    .itemRight{display:flex;flex-direction:column;align-items:flex-end;gap:6px;}
    .tag{display:inline-flex;align-items:center;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
      font-size:11px;color:#cfe0ee;background:rgba(10,16,21,.8);}
    .tag.locked{color:#b3c1cc;border-color:rgba(255,255,255,.10);opacity:.9;}
    .tag.built{color:var(--good);border-color:rgba(34,197,94,.25);}
    .tag.owned{color:#7dd3fc;border-color:rgba(125,211,252,.25);}

    .invRow{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px 0;border-bottom:1px solid rgba(255,255,255,.06);}
    .invRow:last-child{border-bottom:none;}
    .invName{font-size:12px;color:#cfe0ee;}
    .invCount{font-size:12px;color:var(--muted);}
    .log{min-height:190px;background:#070c10;border:1px solid var(--border);border-radius:12px;
      padding:10px;overflow:auto;white-space:pre-wrap;font-size:12px;line-height:1.35;color:#c6d3de;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;}

    @media (max-width: 980px){ .app{grid-template-columns:1fr;} }
  </style>
</head>
<body>
<div class="app">
  <section class="panel">
    <h2>HUD</h2>
    <div class="row"><div class="k">Tick</div><div class="v mono" id="hudTick">0</div></div>
    <div class="row"><div class="k">Mode</div><div class="v"><span class="pill cyan" id="hudMode">SELECT</span></div></div>
    <div class="row"><div class="k">Selected</div><div class="v mono" id="hudSelected">None</div></div>

    <div class="row"><div class="k">System</div><div class="v"><span class="pill bad" id="hudSystem">OFFLINE</span></div></div>
    <div class="row"><div class="k">Power</div><div class="v"><span class="pill bad" id="hudPowerState">RED</span> <span class="mono" id="hudPowerNums">(0.0 / 0.0)</span></div></div>

    <div class="row"><div class="k">Population</div><div class="v mono" id="hudPop">0</div></div>
    <div class="row"><div class="k">Happiness</div><div class="v"><span class="pill warn" id="hudHappyState">NEUTRAL</span> <span class="mono" id="hudHappy">50</span></div></div>
    <div class="row"><div class="k">Money</div><div class="v mono" id="hudMoney">100.00</div></div>

    <div class="row"><div class="k">Fuel</div><div class="v mono" id="hudFuel">0.800</div></div>
    <div class="row"><div class="k">Food</div><div class="v mono" id="hudFood">6.000</div></div>
    <div class="row"><div class="k">Water</div><div class="v mono" id="hudWater">6.000</div></div>

    <div class="row"><div class="k">Life Support</div><div class="v"><span class="pill bad" id="hudLife">OFFLINE</span></div></div>
    <div class="row" style="border-bottom:none;"><div class="k">Generator</div><div class="v"><span class="pill bad" id="hudGen">OFFLINE</span></div></div>
  </section>

  <section class="mapPanel">
    <div class="panel topbar">
      <div class="brand">
        <div class="title">Zone 13</div>
        <div class="sub">v0.2.1 â€¢ Fuel production + population/taxes (fix standstill)</div>
      </div>
      <div class="tools">
        <button id="btnStart">Start</button>
        <button id="btnPause">Pause</button>
        <button id="btnStep">Step Tick</button>
        <button id="btnReset">Reset</button>
        <span class="chip mono">Milestone 2</span>
      </div>
    </div>

    <div class="map panel" id="map">
      <canvas id="c"></canvas>
      <div class="overlayHint">
        <div><b>Click</b> buildings to select.</div>
        <div><b>Toggle Online</b> to activate (fuel/food/water must be ONLINE to produce).</div>
        <div class="mono" style="margin-top:6px;opacity:.85;">ESC cancels placement.</div>
        <div class="mono" style="margin-top:6px;opacity:.70;">System icons are placeholders.</div>
      </div>
    </div>
  </section>

  <section class="rightCol">
    <div class="panel">
      <div class="sectionTitle">
        <h2 style="margin:0;">Store</h2>
        <button id="btnStore" style="padding:6px 10px;">STORE</button>
      </div>

      <div class="box" id="storeBox" style="margin-top:8px;display:none;">
        <div class="sectionTitle">
          <div class="mono">Available</div>
          <div style="font-size:12px;color:#b9c8d4;">Money: <span class="mono" id="storeMoney">100.00</span></div>
        </div>
        <div id="storeItems"></div>
      </div>
    </div>

    <div class="panel">
      <div class="sectionTitle">
        <h2 style="margin:0;">Inventory</h2>
        <span class="chip mono" id="modeTag">SELECT</span>
      </div>
      <div class="box" style="margin-top:8px;">
        <div style="font-size:12px;color:var(--muted);margin-bottom:8px;">Purchased items become placement tokens.</div>
        <div id="invList"></div>
      </div>
    </div>

    <div class="panel">
      <div class="sectionTitle">
        <h2 style="margin:0;">Selection</h2>
        <span class="chip mono" id="selCoord">â€”</span>
      </div>
      <div class="box" style="margin-top:8px;">
        <div class="mono" id="selName" style="font-size:13px;">Nothing selected</div>
        <div id="selState" style="margin-top:8px;color:var(--muted);font-size:12px;">Click a building on the map.</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;">
          <button id="btnToggleOnline" disabled>Toggle</button>
                    <button id="btnDelete" disabled>Remove</button>
          <button id="btnCancelPlace" disabled>Cancel Placement</button>
        </div>
      </div>
    </div>

    <div class="panel" style="display:flex;flex-direction:column;gap:10px;min-height:220px;">
      <h2>Log</h2>
      <div class="log" id="log"></div>
    </div>
  </section>
</div>

<script>

(() => {
  const MAP_COLS = 12, MAP_ROWS = 9;
  const TILE_W = 86, TILE_H = 44, BOARD_PAD_Y = 50;

  // Districts (visual overlay only for now; bonuses will hook in later)
  const DISTRICTS = [
    { id: "power", name: "Power District", color: "rgba(59,130,246,0.10)" },   // blue
    { id: "life",  name: "Life District",  color: "rgba(34,197,94,0.10)" },    // green
    { id: "prod",  name: "Production District", color: "rgba(245,158,11,0.10)" }, // amber
    { id: "civic", name: "Civic District", color: "rgba(168,85,247,0.10)" }    // purple
  ];

  function districtAt(gx, gy){
    const halfX = Math.floor(MAP_COLS/2);
    const halfY = Math.floor(MAP_ROWS/2);
    if (gx < halfX && gy < halfY) return "power";
    if (gx >= halfX && gy < halfY) return "life";
    if (gx < halfX && gy >= halfY) return "prod";
    return "civic";
  }

  function districtColor(id){
    const d = DISTRICTS.find(x => x.id === id);
    return d ? d.color : "rgba(255,255,255,0)";
  }

  function districtAt(gx, gy){
    const halfX = Math.floor(MAP_COLS/2);
    const halfY = Math.floor(MAP_ROWS/2);
    if (gx < halfX && gy < halfY) return "power";
    if (gx >= halfX && gy < halfY) return "life";
    if (gx < halfX && gy >= halfY) return "prod";
    return "civic";
  }

  function districtColor(id){
    const d = DISTRICTS.find(x => x.id === id);
    return d ? d.color : "rgba(255,255,255,0)";
  }

  // ECON tuning
  const START_MONEY = 100;
  const START_FUEL = 0.8;
  const FUEL_CAP = 5.0;
  const FUEL_PROD_PER_TICK = 0.06;
  const FUEL_DRAIN_PER_TICK = 0.06;
  const FOOD_CAP = 10.0, WATER_CAP = 10.0;
  const FOOD_PROD_PER_TICK = 0.04, WATER_PROD_PER_TICK = 0.04;

  // Consumption + scarcity
  const FOOD_CONS_PER_POP_PER_TICK = 0.002;
  const WATER_CONS_PER_POP_PER_TICK = 0.002;
  const SCARCITY_SUSTAIN_TICKS = 25; // ~25 seconds at 1 tick/sec
  const HAPPY_DOWN_SCARCITY = 0.08;
  const HAPPY_DOWN_SUSTAINED_SCARCITY = 0.18;

  // Population + taxes
  const POP_SEED = 12;
  const TAX_PER_PERSON_PER_TICK = 0.01;
  const POP_GROWTH_PER_TICK = 0.03;
  const POP_DECLINE_PER_TICK = 0.04;

  // Happiness
  const HAPPY_UP_STABLE = 0.08;
  const HAPPY_DOWN_UNSTABLE = 0.08;

  const CATALOG = {
    generator:{type:"generator", name:"Generator", cost:50, oneOnly:false, unlock: s => true},
    fuel:    {type:"fuel",    name:"Fuel Station",   cost:30, oneOnly:true,  unlock: s => isLifeOnline(s)},
    food:    {type:"food",    name:"Food Processor", cost:35, oneOnly:true,  unlock: s => isBuilt(s,"fuel")},
    water:   {type:"water",   name:"Water Pump",     cost:40, oneOnly:true,  unlock: s => isBuilt(s,"food")},
    tech:    {type:"tech",    name:"Tech Facility",  cost:60, oneOnly:true,  unlock: s => isBuilt(s,"fuel")},
    housing: {type:"housing", name:"Housing Block",  cost:40, oneOnly:false, unlock: s => isSystemOnline(s)}
  };

  const state = {
    tick:0, running:false, timer:null,
    money:START_MONEY, fuel:START_FUEL, food:6.0, water:6.0,
    pop:0, happy:50,
    foodShortTicks:0, waterShortTicks:0,
    powerSupply:0, powerDemand:0, powerState:"RED",
    buildings:new Map(), builtCount:new Map(),
    selectedKey:null, placingToken:null, hoverTile:null,
    inventory:new Map(),
    storeOpenedOnce:false, storeNeedsNudge:false, popSeeded:false
  };

  const START_GEN = {x:4,y:3};
  const START_LIFE = {x:6,y:3};

  const el = {
    canvas: document.querySelector("#c"),
    map: document.querySelector("#map"),
    log: document.querySelector("#log"),
    hudTick: document.querySelector("#hudTick"),
    hudMode: document.querySelector("#hudMode"),
    hudSelected: document.querySelector("#hudSelected"),
    hudSystem: document.querySelector("#hudSystem"),
    hudPowerState: document.querySelector("#hudPowerState"),
    hudPowerNums: document.querySelector("#hudPowerNums"),
    hudPop: document.querySelector("#hudPop"),
    hudHappyState: document.querySelector("#hudHappyState"),
    hudHappy: document.querySelector("#hudHappy"),
    hudMoney: document.querySelector("#hudMoney"),
    hudFuel: document.querySelector("#hudFuel"),
    hudFood: document.querySelector("#hudFood"),
    hudWater: document.querySelector("#hudWater"),
    hudLife: document.querySelector("#hudLife"),
    hudGen: document.querySelector("#hudGen"),
    btnStart: document.querySelector("#btnStart"),
    btnPause: document.querySelector("#btnPause"),
    btnStep: document.querySelector("#btnStep"),
    btnReset: document.querySelector("#btnReset"),
    btnStore: document.querySelector("#btnStore"),
    storeBox: document.querySelector("#storeBox"),
    storeMoney: document.querySelector("#storeMoney"),
    storeItems: document.querySelector("#storeItems"),
    invList: document.querySelector("#invList"),
    modeTag: document.querySelector("#modeTag"),
    selCoord: document.querySelector("#selCoord"),
    selName: document.querySelector("#selName"),
    selState: document.querySelector("#selState"),
    btnToggleOnline: document.querySelector("#btnToggleOnline"),
    btnDelete: document.querySelector("#btnDelete"),
    btnCancelPlace: document.querySelector("#btnCancelPlace"),
  };

  const ctx = el.canvas.getContext("2d");

// === Visual polish: Containment Platform in a Dead World (safe overlay) ===
// Purely visual: does not affect gameplay state, placement, or economy.
const _worldFx = (() => {
  const oc = document.createElement("canvas");
  oc.width = 256; oc.height = 256;
  const g = oc.getContext("2d");
  // Base dusty terrain
  g.fillStyle = "#14100c";
  g.fillRect(0,0,oc.width,oc.height);
  // Noise
  const img = g.getImageData(0,0,oc.width,oc.height);
  for(let i=0;i<img.data.length;i+=4){
    const n = (Math.random()*255)|0;
    const v = 14 + (n%24);
    img.data[i]   = v+6;  // r
    img.data[i+1] = v+3;  // g
    img.data[i+2] = v;    // b
    img.data[i+3] = 255;
  }
  g.putImageData(img,0,0);
  // Light dust streaks
  g.globalAlpha = 0.15;
  for(let i=0;i<18;i++){
    g.fillStyle = i%2 ? "#2a211a" : "#201813";
    const y = (Math.random()*256)|0;
    const h = 2 + ((Math.random()*6)|0);
    g.fillRect(0,y,256,h);
  }
  g.globalAlpha = 1;
  // Sparse grit specks
  g.globalAlpha = 0.25;
  for(let i=0;i<220;i++){
    g.fillStyle = (i%3===0) ? "#3a2f25" : "#221a14";
    const x = (Math.random()*256)|0;
    const y = (Math.random()*256)|0;
    g.fillRect(x,y,1,1);
  }
  g.globalAlpha = 1;

  return { patternCanvas: oc, pattern: null };
})();

function _ensureWorldPattern(){
  if(!_worldFx.pattern){
    _worldFx.pattern = ctx.createPattern(_worldFx.patternCanvas, "repeat");
  }
}

function drawWorld(origin, r){
  _ensureWorldPattern();

  // Terrain background
  ctx.globalAlpha = 1;
  ctx.fillStyle = _worldFx.pattern;
  ctx.fillRect(0,0,r.width,r.height);

  // Compute platform corners (slab under the map)
  const pad = 1.25;
  const A = tileToScreen(-pad, -pad);
  const B = tileToScreen(MAP_COLS+pad, -pad);
  const C = tileToScreen(MAP_COLS+pad, MAP_ROWS+pad);
  const D = tileToScreen(-pad, MAP_ROWS+pad);

  const ax = origin.x + A.x, ay = origin.y + A.y;
  const bx = origin.x + B.x, by = origin.y + B.y;
  const cx = origin.x + C.x, cy = origin.y + C.y;
  const dx = origin.x + D.x, dy = origin.y + D.y;

  // Drop shadow for depth (directional)
  ctx.save();
  ctx.globalAlpha = 0.55;
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.beginPath();
  ctx.moveTo(ax+18, ay+22);
  ctx.lineTo(bx+18, by+22);
  ctx.lineTo(cx+18, cy+22);
  ctx.lineTo(dx+18, dy+22);
  ctx.closePath();
  ctx.filter = "blur(14px)";
  ctx.fill();
  ctx.restore();

  // Slab fill (concrete/steel plate)
  const slabGrad = ctx.createLinearGradient(ax, ay, cx, cy);
  slabGrad.addColorStop(0, "rgba(28,30,33,0.96)");
  slabGrad.addColorStop(1, "rgba(18,20,23,0.96)");
  ctx.fillStyle = slabGrad;
  ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(bx, by);
  ctx.lineTo(cx, cy);
  ctx.lineTo(dx, dy);
  ctx.closePath();
  ctx.fill();

  // Edge highlight + wear
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(bx, by);
  ctx.lineTo(cx, cy);
  ctx.lineTo(dx, dy);
  ctx.closePath();
  ctx.stroke();

  // Subtle cracks/scratches on slab (procedural, cheap)
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  for(let i=0;i<26;i++){
    const t = i/26;
    const sx = ax*(1-t)+cx*t + (Math.random()*36-18);
    const sy = ay*(1-t)+cy*t + (Math.random()*26-13);
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(sx + (Math.random()*40-20), sy + (Math.random()*28-14));
    ctx.stroke();
  }
  ctx.restore();

  // Atmospheric vignette (keeps focus on the platform)
  const vg = ctx.createRadialGradient(r.width*0.5, r.height*0.55, Math.min(r.width,r.height)*0.15,
                                     r.width*0.5, r.height*0.55, Math.max(r.width,r.height)*0.75);
  vg.addColorStop(0, "rgba(0,0,0,0.00)");
  vg.addColorStop(1, "rgba(0,0,0,0.62)");
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,r.width,r.height);
}
// === End visual polish ===

  const keyOf = (x,y)=>`${x},${y}`;
  const clamp = (v,lo,hi)=>Math.max(lo,Math.min(hi,v));

  function log(msg){
    const t = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
    el.log.textContent += `[${t}] ${msg}\n`;
    el.log.scrollTop = el.log.scrollHeight;
  }

  function getB(x,y){ return state.buildings.get(keyOf(x,y)) || null; }
  function setB(b){
    state.buildings.set(keyOf(b.x,b.y), b);
    state.builtCount.set(b.type, (state.builtCount.get(b.type)||0) + 1);
  }
  function delB(x,y){
    const b = getB(x,y);
    if(!b) return;
    state.buildings.delete(keyOf(x,y));
    state.builtCount.set(b.type, Math.max(0,(state.builtCount.get(b.type)||1)-1));
  }
  function isBuilt(s,type){ return (s.builtCount.get(type)||0) > 0; }
  function isOwned(s,type){ return (s.builtCount.get(type)||0) > 0 || (s.inventory.get(type)||0) > 0; }
  function countOnline(type){
    let n=0;
    for(const b of state.buildings.values()) if(b.type===type && b.online) n++;
    return n;
  }
  function isGenOnline(){ return !!getB(START_GEN.x,START_GEN.y)?.online; }
  function isLifeOnline(){ return !!getB(START_LIFE.x,START_LIFE.y)?.online; }
  function isSystemOnline(){ return isGenOnline() && isLifeOnline() && state.powerState!=="RED"; }

  function tileToScreen(x,y){
    return {x:(x-y)*(TILE_W/2), y:(x+y)*(TILE_H/2)};
  }
  function screenToTile(px,py){
    const x = (px/(TILE_W/2) + py/(TILE_H/2)) / 2;
    const y = (py/(TILE_H/2) - px/(TILE_W/2)) / 2;
    return {x,y};
  }
  function boardOrigin(){
    const r = el.map.getBoundingClientRect();
    return {x:r.width/2, y:BOARD_PAD_Y};
  }
  function inBounds(x,y){ return x>=0 && y>=0 && x<MAP_COLS && y<MAP_ROWS; }

  function start(){
    if(state.running) return;
    state.running=true;
    state.timer=setInterval(tick, 1000);
    log("ENGINE start");
    renderAll();
  }
  function pause(){
    if(!state.running) return;
    state.running=false;
    clearInterval(state.timer);
    state.timer=null;
    log("ENGINE pause");
    renderAll();
  }
  function step(){ tick(); }

  function tick(){
    state.tick++;

    // Production (FIX: fuel now increases)
    const fOn = countOnline("fuel");
    const foodOn = countOnline("food");
    const waterOn = countOnline("water");

    if(fOn>0) state.fuel = Math.min(FUEL_CAP, state.fuel + FUEL_PROD_PER_TICK*fOn);
    if(foodOn>0) state.food = Math.min(FOOD_CAP, state.food + FOOD_PROD_PER_TICK*foodOn);
    if(waterOn>0) state.water = Math.min(WATER_CAP, state.water + WATER_PROD_PER_TICK*waterOn);

    
    // Consumption (population drives demand)
    const popNow = state.pop;
    let foodShort = false, waterShort = false;
    if(popNow > 0){
      const needFood = popNow * FOOD_CONS_PER_POP_PER_TICK;
      const needWater = popNow * WATER_CONS_PER_POP_PER_TICK;

      if(state.food + 1e-9 < needFood){ foodShort = true; state.food = 0; }
      else state.food = Math.max(0, state.food - needFood);

      if(state.water + 1e-9 < needWater){ waterShort = true; state.water = 0; }
      else state.water = Math.max(0, state.water - needWater);
    }

    // Scarcity counters (Stage 1 -> happiness pressure, Stage 2 -> population decline)
    if(foodShort) state.foodShortTicks++; else state.foodShortTicks = Math.max(0, state.foodShortTicks - 2);
    if(waterShort) state.waterShortTicks++; else state.waterShortTicks = Math.max(0, state.waterShortTicks - 2);
    const scarcitySustained = (state.foodShortTicks >= SCARCITY_SUSTAIN_TICKS) || (state.waterShortTicks >= SCARCITY_SUSTAIN_TICKS);

    // Power model (Phase 1 badge reads derived state; keep this core simple)
// - Supply: sum of ONLINE generators (requires fuel)
// - Demand: Life Support + (Phase 4) online producers/utility buildings that draw power
const GEN_OUTPUT = 1.6;
const LIFE_DEMAND = 1.0;

// Phase 4: power coupling (keep it light for early game; tune later)
const FUEL_DEMAND  = 0.05;  // fuel station/pump draw
const FOOD_DEMAND  = 0.25;  // food processor draw
const WATER_DEMAND = 0.25;  // water pump draw
const TECH_DEMAND  = 0.15;  // tech facility draw (if present)

const onlineGens = countOnline("generator");
const onlineLife = countOnline("life");

const demandFuel = countOnline("fuel")  * FUEL_DEMAND;
const demandFood = countOnline("food")  * FOOD_DEMAND;
const demandWater= countOnline("water") * WATER_DEMAND;
const demandTech = countOnline("tech")  * TECH_DEMAND;

state.powerDemand = (onlineLife * LIFE_DEMAND) + demandFuel + demandFood + demandWater + demandTech;
    // If fuel is empty, generators cannot produce.
    state.powerSupply = (state.fuel > 0 ? (onlineGens * GEN_OUTPUT) : 0);

    // Canon badge states (OFFLINE / CRITICAL / STRAINED / STABLE)
    const sup = Number(state.powerSupply||0);
    const dem = Number(state.powerDemand||0);
    if(sup <= 0.000001) state.powerState = "OFFLINE";
    else if(dem <= 0.000001) state.powerState = "STABLE";
    else if(sup < dem) state.powerState = "CRITICAL";
    else {
      const buffer = 0.10 * dem;
      state.powerState = (sup < dem + buffer) ? "STRAINED" : "STABLE";
    }

    // Phase 2: Fuel Drain (authoritative)
    // - Any ONLINE generator consumes fuel continuously, even if nothing is drawing power yet.
    // - If fuel hits 0, generator is forced OFFLINE.

    // Drain fuel for ALL online generators.
    const gensOnlineNow = [];
    for(const b of state.buildings.values()){
      if(b.type === "generator" && b.online) gensOnlineNow.push(b);
    }
    if(gensOnlineNow.length){
      if(state.fuel > 0){
        const drain = FUEL_DRAIN_PER_TICK * gensOnlineNow.length;
        state.fuel = Math.max(0, state.fuel - drain);
      }
      if(state.fuel === 0){
        for(const g of gensOnlineNow) g.online = false;
        log("Generators OFFLINE (fuel depleted)");
      }
    }

    // Happiness (scarcity affects happiness first; population reacts later)
    const stable = isSystemOnline();
    let happyDelta = (stable?HAPPY_UP_STABLE:-HAPPY_DOWN_UNSTABLE);
    if(foodShort || waterShort) happyDelta -= HAPPY_DOWN_SCARCITY;
    if(scarcitySustained) happyDelta -= HAPPY_DOWN_SUSTAINED_SCARCITY;
    state.happy = clamp(state.happy + happyDelta, 0, 100);
    const hs = state.happy>=70 ? "GREEN" : state.happy<=35 ? "RED" : "NEUTRAL";

    // Pop seed + dynamics (FIX: pop moves)
    if(stable && !state.popSeeded){
      state.pop = POP_SEED;
      state.popSeeded=true;
      log(`Population seeded: ${POP_SEED}`);
      if(!state.storeOpenedOnce) state.storeNeedsNudge=true;
    }
    if(stable && hs==="GREEN" && !scarcitySustained) state.pop += POP_GROWTH_PER_TICK;
    else if(!stable) state.pop -= POP_DECLINE_PER_TICK;
    else if(scarcitySustained && hs==="RED") state.pop -= POP_DECLINE_PER_TICK;
    state.pop = Math.max(0, state.pop);

    // Taxes (FIX: money keeps moving)
    if(stable && state.pop>0) state.money += state.pop * TAX_PER_PERSON_PER_TICK;

    // Store nudge
    if(isLifeOnline() && !state.storeOpenedOnce) state.storeNeedsNudge=true;

    renderAll();
  }

  function reset(){
    pause();
    state.tick=0;
    state.money=START_MONEY;
    state.fuel=START_FUEL;
    state.food=6.0;
    state.water=6.0;
    state.pop=0;
    state.happy=50;
    state.foodShortTicks=0; state.waterShortTicks=0;
    state.powerSupply=0; state.powerDemand=0; state.powerState="RED";

    state.buildings.clear();
    state.builtCount.clear();
    state.selectedKey=null;
    state.placingToken=null;
    state.hoverTile=null;
    state.inventory.clear();

    state.storeOpenedOnce=false;
    state.storeNeedsNudge=false;
    state.popSeeded=false;

    setB({type:"generator", name:"Generator", online:false, x:START_GEN.x, y:START_GEN.y});
    setB({type:"life", name:"Life Support", online:false, x:START_LIFE.x, y:START_LIFE.y});

    el.storeBox.style.display="none";
    el.btnStore.classList.remove("glowPulse");

    log("RESET complete");
    renderAll();
  }

  function toggleStore(){
    const open = el.storeBox.style.display!=="none";
    el.storeBox.style.display = open ? "none" : "block";
    if(!open){
      state.storeOpenedOnce=true;
      state.storeNeedsNudge=false;
      el.btnStore.classList.remove("glowPulse");
      log("STORE opened");
    } else log("STORE closed");
    renderStore();
  }

  function purchase(type){
    const item = CATALOG[type];
    if(!item) return;
    if(!item.unlock(state)){ log(`${item.name} is LOCKED.`); return; }
    if(item.oneOnly && isBuilt(state,type)){ log(`${item.name} already built.`); return; }
    if(state.money < item.cost){ log(`Insufficient funds for ${item.name}.`); return; }
    state.money -= item.cost;
    state.inventory.set(type, (state.inventory.get(type)||0)+1);
    log(`Purchased: ${item.name} (+1 token)`);
    beginTokenPlacement(type);
    renderAll();
  }

  function beginTokenPlacement(type){
    const item = CATALOG[type];
    if(!item) return;
    if((state.inventory.get(type)||0) <= 0){ log(`No ${item.name} tokens.`); return; }
    state.placingToken = {type, name:item.name};
    state.selectedKey = null;
    el.btnCancelPlace.disabled=false;
    log(`Placement mode: ${item.name}`);
    renderAll();
  }
  function cancelPlacement(){
    if(!state.placingToken) return;
    state.placingToken=null;
    el.btnCancelPlace.disabled=true;
    log("Placement cancelled (token kept).");
    renderAll();
  }

  function selectKey(k){
    state.selectedKey=k;
    state.placingToken=null;
    el.btnCancelPlace.disabled=true;
    renderAll();
  }
  function clearSelection(){ state.selectedKey=null; renderAll(); }

  function toggleSelectedOnline(){
  if(!state.selectedKey) return;
  const b = state.buildings.get(state.selectedKey);
  if(!b) return;
  b.online = !b.online;
  log((b.name||b.type)+" "+(b.online?"ONLINE":"OFFLINE"));
  renderAll();
}

function deleteSelected(){
    if(!state.selectedKey) return;
    const b = state.buildings.get(state.selectedKey);
    if(!b) return;
    if((b.x===START_GEN.x && b.y===START_GEN.y) || (b.x===START_LIFE.x && b.y===START_LIFE.y)){
      log("Cannot remove starter buildings in v0.2.1");
      return;
    }

    // Return building to inventory instead of deleting it forever.
    // This prevents new players from soft-locking themselves by experimenting with Remove.
    const type = b.type;
    const item = CATALOG[type];
    if(item){
      const cur = state.inventory.get(type)||0;
      if(item.oneOnly){
        // one-only items should never accumulate multiple tokens
        state.inventory.set(type, Math.min(1, cur + 1));
      } else {
        state.inventory.set(type, cur + 1);
      }
    }

    delB(b.x,b.y);
    log(`Removed to inventory: ${b.name}`);
    state.selectedKey=null;
    renderAll();
  }

  function renderHUD(){
    el.hudTick.textContent = String(state.tick);
    const mode = state.placingToken ? "PLACE" : "SELECT";
    el.hudMode.textContent = mode;
    el.modeTag.textContent = mode;

    const sel = state.selectedKey ? state.buildings.get(state.selectedKey) : null;
    el.hudSelected.textContent = sel ? `${sel.name} @ ${sel.x},${sel.y}` : "None";

    const sysOn = isSystemOnline();
    el.hudSystem.textContent = sysOn ? "ONLINE" : "OFFLINE";
    el.hudSystem.className = "pill " + (sysOn ? "good" : "bad");

    el.hudPowerState.textContent = state.powerState;
    el.hudPowerState.className = "pill " + (state.powerState==="STABLE" ? "good" : state.powerState==="STRAINED" ? "warn" : "bad");
    el.hudPowerNums.textContent = `(${state.powerSupply.toFixed(1)} / ${state.powerDemand.toFixed(1)})`;

    el.hudPop.textContent = String(Math.floor(state.pop));
    const hs = state.happy>=70 ? "GREEN" : state.happy<=35 ? "RED" : "NEUTRAL";
    el.hudHappyState.textContent = hs;
    el.hudHappyState.className = "pill " + (hs==="GREEN" ? "good" : hs==="RED" ? "bad" : "warn");
    el.hudHappy.textContent = String(Math.round(state.happy));

    el.hudMoney.textContent = state.money.toFixed(2);
    el.storeMoney.textContent = state.money.toFixed(2);

    el.hudFuel.textContent = state.fuel.toFixed(3);
    el.hudFood.textContent = state.food.toFixed(3);
    el.hudWater.textContent = state.water.toFixed(3);

    const genCount = countOnline("generator");
    const life = getB(START_LIFE.x,START_LIFE.y);
    el.hudGen.textContent = genCount>0 ? `ONLINE (${genCount})` : "OFFLINE";
    el.hudGen.className = "pill " + (genCount>0 ? "good" : "bad");
    el.hudLife.textContent = life?.online ? "ONLINE" : "OFFLINE";
    el.hudLife.className = "pill " + (life?.online ? "good" : "bad");

    if(state.storeNeedsNudge) el.btnStore.classList.add("glowPulse");
  }

  function storeHint(type, locked, placed, owned){
    if(placed) return "Already built."; 
    if(owned) return "Owned. Place from inventory.";
    if(locked){
      if(type==="fuel") return "Unlock: Life Support ONLINE.";
      if(type==="food") return "Unlock: Fuel Station built.";
      if(type==="water") return "Unlock: Food Processor built.";
      if(type==="tech") return "Unlock: Fuel Station built.";
      if(type==="housing") return "Unlock: System ONLINE.";
      return "Locked.";
    }
    if(type==="housing") return "Repeatable. Raises capacity later.";
    if(type==="tech") return "One-only. Generates tech points later.";
    if(type==="fuel") return "Produces fuel while ONLINE.";
    if(type==="food") return "Produces food while ONLINE.";
    if(type==="water") return "Produces water while ONLINE.";
    return "Purchase creates a placement token.";
  }

  function renderStore(){
    el.storeItems.innerHTML="";
    for(const [k,item] of Object.entries(CATALOG)){
      const locked = !item.unlock(state);
      const placed = item.oneOnly && isBuilt(state,item.type);
      const owned = item.oneOnly && isOwned(state,item.type);
      const canBuy = !locked && !owned && state.money>=item.cost;

      const div = document.createElement("div");
      div.className="item";

      const left = document.createElement("div");
      left.innerHTML = `<div class="itemTitle">${item.name}</div><div class="itemMeta">${storeHint(item.type,locked,placed,owned)}</div>`;

      const right = document.createElement("div");
      right.className="itemRight";

      const tag = document.createElement("div");
      tag.className="tag " + (placed ? "built" : locked ? "locked" : owned ? "owned" : "");
      tag.textContent = placed ? "BUILT" : locked ? "LOCKED" : owned ? "OWNED" : "AVAILABLE";

      const cost = document.createElement("div");
      cost.className="mono"; cost.style.fontSize="12px";
      cost.textContent = `Cost: ${item.cost}`;

      const btn = document.createElement("button");
      btn.textContent = owned ? "Owned" : "Buy";
      btn.disabled = owned || locked || !canBuy;
      btn.addEventListener("click", ()=>purchase(item.type));

      right.appendChild(tag); right.appendChild(cost); right.appendChild(btn);
      div.appendChild(left); div.appendChild(right);
      el.storeItems.appendChild(div);
    }
  }

  function renderInventory(){
    el.invList.innerHTML="";
    const keys = [...state.inventory.keys()];
    if(keys.length===0){
      const d=document.createElement("div");
      d.style.color="var(--muted)"; d.style.fontSize="12px";
      d.textContent="No tokens yet. Buy something in the store.";
      el.invList.appendChild(d);
      return;
    }
    for(const type of keys){
      const count = state.inventory.get(type)||0;
      if(count<=0) continue;
      const item = CATALOG[type];

      const row=document.createElement("div");
      row.className="invRow";

      const left=document.createElement("div");
      left.innerHTML = `<div class="invName">${item.name}</div><div class="invCount">Tokens: <span class="mono">${count}</span></div>`;

      const btn=document.createElement("button");
      btn.textContent="Place";
      btn.addEventListener("click", ()=>beginTokenPlacement(type));

      row.appendChild(left); row.appendChild(btn);
      el.invList.appendChild(row);
    }
  }

  function renderSelectionPanel(){
    const sel = state.selectedKey ? state.buildings.get(state.selectedKey) : null;
    if(!sel){
      el.selCoord.textContent="â€”";
      el.selName.textContent="Nothing selected";
      el.selState.textContent = state.placingToken ? `Placing: ${state.placingToken.name}. Click an empty tile.` : "Click a building on the map.";
      el.btnToggleOnline.disabled=true;
    el.btnToggleOnline.textContent="Toggle ONLINE";
      el.btnDelete.disabled=true;
      el.btnCancelPlace.disabled=!state.placingToken;
      return;
    }
    el.selCoord.textContent = `${sel.x},${sel.y}`;
    el.selName.textContent = sel.name;
    el.selState.innerHTML = `<div style="font-size:12px;color:var(--muted);line-height:1.4;">
      Type: <span class="mono">${sel.type}</span><br/>
      Status: <span class="mono">${sel.online ? "ONLINE":"OFFLINE"}</span></div>`;
    el.btnToggleOnline.disabled=false;
        el.btnToggleOnline.textContent = sel.online ? "Toggle OFFLINE" : "Toggle ONLINE";
el.btnDelete.disabled=false;
  }

  function renderAll(){
    renderHUD();
    renderStore();
    renderInventory();
    renderSelectionPanel();
    draw();
  }

  function resizeCanvas(){
    const r = el.map.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    el.canvas.width = Math.floor(r.width*dpr);
    el.canvas.height = Math.floor(r.height*dpr);
    el.canvas.style.width = r.width+"px";
    el.canvas.style.height = r.height+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resizeCanvas);

  function draw(){
    const r = el.map.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);
    const origin = boardOrigin();

    drawWorld(origin, r);

    for(let y=0;y<MAP_ROWS;y++) for(let x=0;x<MAP_COLS;x++) drawTile(x,y,origin);

    const arr=[...state.buildings.values()].sort((a,b)=>(a.x+a.y)-(b.x+b.y));
    for(const b of arr) drawBuilding(b,origin);

    if(state.placingToken && state.hoverTile){
      const {x,y}=state.hoverTile;
      if(inBounds(x,y) && !getB(x,y)) drawGhost(x,y,origin);
    }

    if(state.selectedKey){
      const b = state.buildings.get(state.selectedKey);
      if(b) drawSelectRing(b.x,b.y,origin);
    }
  }

  function drawTile(x,y,origin){
    const p = tileToScreen(x,y);
    const cx = origin.x + p.x;
    const cy = origin.y + p.y;

    const hover = state.hoverTile && state.hoverTile.x===x && state.hoverTile.y===y;
    const occupied = !!getB(x,y);
    const fill = occupied ? "rgba(10,16,21,.90)" : "rgba(9,14,19,.85)";
    const stroke = hover ? "rgba(34,211,238,.55)" : "rgba(255,255,255,.10)";

    ctx.beginPath();
    ctx.moveTo(cx, cy - TILE_H/2);
    ctx.lineTo(cx + TILE_W/2, cy);
    ctx.lineTo(cx, cy + TILE_H/2);
    ctx.lineTo(cx - TILE_W/2, cy);
    ctx.closePath();

    // District tint underlay (keeps the original look, but hints planning zones)
    const dcol = districtColor(districtAt(x,y));
    if(!occupied){ ctx.fillStyle=dcol; ctx.fill(); }

    ctx.fillStyle=fill; ctx.globalAlpha = occupied ? 1.0 : 0.90; ctx.fill();
    ctx.globalAlpha = 1.0;
    ctx.lineWidth=1; ctx.strokeStyle=stroke; ctx.stroke();
  }

  function roundRect(x,y,w,h,r,fill,stroke,fillStyle,strokeStyle){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    if(fill){ ctx.fillStyle=fillStyle||"rgba(9,16,22,.9)"; ctx.fill(); }
    if(stroke){ ctx.strokeStyle=strokeStyle||"rgba(255,255,255,.10)"; ctx.stroke(); }
  }

  function shortLabel(type){
    switch(type){
      case "generator": return "GENERATOR";
      case "life": return "LIFE SUPPORT";
      case "fuel": return "FUEL";
      case "food": return "FOOD";
      case "water": return "WATER";
      case "tech": return "TECH";
      case "housing": return "HOUSING";
      default: return "UNIT";
    }
  }

  function iconForType(type){
    switch(type){
      case "generator": return "âš¡";
      case "life": return "â›‘";
      case "fuel": return "â›½";
      case "food": return "â¬¢";
      case "water": return "ðŸ’§";
      case "tech": return "âŒ¬";
      case "housing": return "â–¦";
      default: return "â– ";
    }
  }

  function iconColor(type, online){
    // Placeholder palette: muted when offline, slightly themed per system when online.
    if(!online) return "rgba(214,222,230,.35)";
    switch(type){
      case "generator": return "rgba(34,197,94,.95)";      // green
      case "life": return "rgba(34,211,238,.92)";          // cyan
      case "fuel": return "rgba(234,179,8,.92)";           // amber
      case "water": return "rgba(96,165,250,.92)";         // blue-ish
      case "food": return "rgba(163,230,53,.92)";          // lime
      case "tech": return "rgba(217,70,239,.85)";          // magenta
      case "housing": return "rgba(248,113,113,.85)";      // soft red
      default: return "rgba(214,222,230,.70)";
    }
  }


  function powerPulseState(){
    // Canon pulse states (v1.1): STABLE (green/calm), STRAINED (amber), CRITICAL (red/rapid), OFFLINE (dim)
    // Purely visual: derived from existing supply/demand if full word state isn't present.
    const sup = Number(state.powerSupply||0);
    const dem = Number(state.powerDemand||0);
    if(state.powerState) return state.powerState; // if engine provides it, use it
    if(sup<=0.000001) return "OFFLINE";
    if(dem<=0.000001) return "STABLE";
    if(sup < dem) return "CRITICAL";
    const buffer = 0.10 * dem;
    if(sup < dem + buffer) return "STRAINED";
    return "STABLE";
  }

  function drawPowerBadge(cx, topY, isOnline){
    // Large industrial badge above generator card. Purely visual.
    const mode = powerPulseState();
    const online = !!isOnline;
    const r = 18;
    const bx = cx;
    const by = topY - 18;

    // Pulse speeds (per tick) and base alpha
    let speed = 0.04, baseA = 0.75;
    let col = "rgba(214,222,230,.35)";
    if(online){
      if(mode==="STABLE"){ col="rgba(34,197,94,.95)"; speed=0.025; baseA=0.75; }
      if(mode==="STRAINED"){ col="rgba(234,179,8,.92)"; speed=0.018; baseA=0.68; }
      if(mode==="CRITICAL"){ col="rgba(239,68,68,.92)"; speed=0.06; baseA=0.70; }
    }
    const pulse = online ? (baseA + (Math.sin(state.tick*speed)*0.18)) : 0.25;

    ctx.save();
    // Outer glow
    if(online){
      ctx.globalAlpha = Math.max(0, Math.min(1, pulse));
      ctx.beginPath();
      ctx.arc(bx, by, r+8, 0, Math.PI*2);
      ctx.fillStyle = col;
      ctx.filter = "blur(10px)";
      ctx.fill();
      ctx.filter = "none";
    }

    // Plate
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(bx, by, r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(9,16,22,.94)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.stroke();

    // Bolt rivets
    const riv = 2.2;
    for(const a of [0, Math.PI/2, Math.PI, 3*Math.PI/2]){
      const rx = bx + Math.cos(a)*(r-5);
      const ry = by + Math.sin(a)*(r-5);
      ctx.beginPath();
      ctx.arc(rx, ry, riv, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,.18)";
      ctx.fill();
    }

    // Lightning glyph
    ctx.globalAlpha = online ? 1 : 0.55;
    ctx.fillStyle = col;
    ctx.font = "18px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("âš¡", bx, by+0.5);

    // Small mode dot (diagnostic)
    let dot = "rgba(214,222,230,.35)";
    if(online){
      if(mode==="STABLE") dot="rgba(34,197,94,.95)";
      if(mode==="STRAINED") dot="rgba(234,179,8,.92)";
      if(mode==="CRITICAL") dot="rgba(239,68,68,.92)";
    }
    ctx.globalAlpha = online ? 0.95 : 0.35;
    ctx.beginPath();
    ctx.arc(bx + r - 4, by + r - 4, 3.2, 0, Math.PI*2);
    ctx.fillStyle = dot;
    ctx.fill();

    ctx.restore();
  }

  function drawBuilding(b,origin){
    const p=tileToScreen(b.x,b.y);
    const cx=origin.x+p.x, cy=origin.y+p.y;

    // Small helper: soft halo so buildings pop on the muted slab
    function halo(color, alphaBase, speed){
      if(!b.online) return;
      ctx.save();
      const pulse = 0.55 + 0.15*Math.sin(state.tick*(speed||0.06));
      ctx.globalAlpha = alphaBase + pulse*alphaBase;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(cx, cy-6, 26, 12, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Small helper: crisp outline
    function outlineRect(x,y,w,h,stroke){
      ctx.save();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.strokeRect(x,y,w,h);
      ctx.restore();
    }

    // Common label style
    function smallTag(text, x, y){
      ctx.save();
      ctx.fillStyle="rgba(10,12,14,0.65)";
      roundRect(x-16, y-9, 32, 18, 8, true, false, null, null);
      ctx.fillStyle="rgba(255,255,255,0.92)";
      ctx.font="10px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(text, x, y+0.5);
      ctx.restore();
    }

    const topY = cy-36;

    // === GENERATOR: bright industrial red (visibility-first) ===
    if(b.type==="generator"){
      const GEN_GLOW = "rgba(255,70,70,1)";
      const GEN_BASE = "rgba(140,25,25,0.98)";
      const GEN_BODY = "rgba(220,55,55,0.96)";
      const GEN_VENT = "rgba(95,15,15,1)";
      const GEN_RIB  = "rgba(255,255,255,0.12)";
      const GEN_PANEL_ON  = "rgba(255,210,90,1)";
      const GEN_PANEL_OFF = "rgba(255,255,255,0.25)";

      halo(GEN_GLOW, 0.16, 0.05);

      // drop shadow
      ctx.save(); ctx.globalAlpha=0.38; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // base + body
      ctx.fillStyle=GEN_BASE; ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(255,90,90,0.55)");

      ctx.fillStyle=GEN_BODY; ctx.fillRect(cx-14, cy-40, 28, 26);
      outlineRect(cx-14, cy-40, 28, 26, "rgba(255,120,120,0.6)");

      // ribs
      ctx.strokeStyle=GEN_RIB; ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(cx-7, cy-40); ctx.lineTo(cx-7, cy-14);
      ctx.moveTo(cx+7, cy-40); ctx.lineTo(cx+7, cy-14);
      ctx.stroke();

      // vent stack
      ctx.fillStyle=GEN_VENT; ctx.fillRect(cx-4, cy-52, 8, 12);

      // panel glow
      ctx.save();
      ctx.globalAlpha = b.online ? (0.78 + 0.18*Math.sin(state.tick*0.06)) : 1.0;
      ctx.fillStyle = b.online ? GEN_PANEL_ON : GEN_PANEL_OFF;
      ctx.fillRect(cx-4, cy-32, 8, 8);
      ctx.restore();

      // tiny fan (micro motion)
      if(b.online){
        ctx.save();
        ctx.translate(cx, cy-46);
        ctx.rotate(state.tick*0.05);
        ctx.globalAlpha=0.75;
        ctx.strokeStyle="rgba(255,230,170,0.9)";
        ctx.lineWidth=1.5;
        ctx.beginPath();
        ctx.moveTo(-5,0); ctx.lineTo(5,0);
        ctx.moveTo(0,-5); ctx.lineTo(0,5);
        ctx.stroke();
        ctx.restore();
      }

      smallTag("GEN", cx, cy-6);
      drawPowerBadge(cx, topY-18, b.online);
      return;
    }

    // === FUEL STATION: caution-amber, high contrast ===
    if(b.type==="fuel"){
      const FUEL_GLOW = "rgba(255,210,70,1)";
      const FUEL_BASE = "rgba(80,55,15,0.98)";
      const FUEL_TANK = "rgba(255,200,60,0.98)";      // brighter!
      const FUEL_TANK2= "rgba(255,230,130,0.95)";
      const FUEL_PIPE = "rgba(35,24,8,1)";
      const STRIPE    = "rgba(20,14,6,0.85)";

      halo(FUEL_GLOW, 0.14, 0.06);

      // shadow
      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // base
      ctx.fillStyle=FUEL_BASE; ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(255,210,70,0.55)");

      // tank block
      ctx.fillStyle=FUEL_TANK; ctx.fillRect(cx-14, cy-42, 28, 28);
      outlineRect(cx-14, cy-42, 28, 28, "rgba(255,240,160,0.65)");

      // caution stripes
      ctx.save();
      ctx.strokeStyle=STRIPE; ctx.lineWidth=3;
      for(let i=-18;i<=18;i+=8){
        ctx.beginPath();
        ctx.moveTo(cx-14+i, cy-42);
        ctx.lineTo(cx-14+i+14, cy-14);
        ctx.stroke();
      }
      ctx.restore();

      // highlight cap
      ctx.fillStyle=FUEL_TANK2;
      ctx.fillRect(cx-10, cy-38, 20, 6);

      // pipe/nozzle
      ctx.fillStyle=FUEL_PIPE;
      ctx.fillRect(cx+10, cy-26, 10, 5);
      ctx.fillRect(cx+18, cy-28, 4, 10);

      // indicator lamp
      ctx.save();
      ctx.globalAlpha = b.online ? (0.75 + 0.2*Math.sin(state.tick*0.07)) : 0.35;
      ctx.fillStyle = "rgba(255,120,30,1)";
      ctx.beginPath(); ctx.arc(cx-10, cy-26, 3.5, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      smallTag("FUEL", cx, cy-6);
      // keep existing badge style for now (simple + readable)
      drawPowerBadge(cx, topY-18, b.online);
      return;
    }

    // === LIFE SUPPORT: cool-cyan facility ===
    if(b.type==="life"){
      const C="rgba(80,220,255,1)";
      halo(C, 0.12, 0.055);

      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // base
      ctx.fillStyle="rgba(18,28,34,0.98)";
      ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(120,240,255,0.45)");

      // dome
      ctx.fillStyle="rgba(40,160,190,0.95)";
      ctx.beginPath(); ctx.arc(cx, cy-30, 14, Math.PI, 0); ctx.closePath(); ctx.fill();
      ctx.strokeStyle="rgba(200,250,255,0.35)"; ctx.lineWidth=2; ctx.stroke();

      // panel
      ctx.save();
      ctx.globalAlpha = b.online ? (0.75 + 0.18*Math.sin(state.tick*0.06)) : 0.35;
      ctx.fillStyle="rgba(190,255,255,0.95)";
      ctx.fillRect(cx-4, cy-20, 8, 6);
      ctx.restore();

      smallTag("LIFE", cx, cy-6);
      drawPowerBadge(cx, topY-18, b.online);
      return;
    }

    // === FOOD: vivid green processor ===
    if(b.type==="food"){
      const C="rgba(110,255,110,1)";
      halo(C, 0.12, 0.06);

      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.fillStyle="rgba(16,26,18,0.98)";
      ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(140,255,140,0.45)");

      ctx.fillStyle="rgba(70,180,90,0.95)";
      ctx.fillRect(cx-14, cy-42, 28, 28);
      outlineRect(cx-14, cy-42, 28, 28, "rgba(200,255,200,0.35)");

      // indicator
      ctx.save();
      ctx.globalAlpha = b.online ? (0.75 + 0.2*Math.sin(state.tick*0.065)) : 0.35;
      ctx.fillStyle="rgba(220,255,220,0.95)";
      ctx.beginPath(); ctx.arc(cx, cy-28, 4, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      smallTag("FOOD", cx, cy-6);
      drawPowerBadge(cx, topY-18, b.online);
      return;
    }

    // === WATER: bright blue pump ===
    if(b.type==="water"){
      const C="rgba(90,170,255,1)";
      halo(C, 0.12, 0.06);

      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.fillStyle="rgba(14,22,30,0.98)";
      ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(120,200,255,0.45)");

      ctx.fillStyle="rgba(60,120,190,0.95)";
      ctx.fillRect(cx-14, cy-40, 28, 26);
      outlineRect(cx-14, cy-40, 28, 26, "rgba(200,230,255,0.35)");

      // small tower
      ctx.fillStyle="rgba(40,90,140,1)";
      ctx.fillRect(cx-3, cy-52, 6, 12);

      // droplet lamp
      ctx.save();
      ctx.globalAlpha = b.online ? (0.75 + 0.2*Math.sin(state.tick*0.07)) : 0.35;
      ctx.fillStyle="rgba(210,240,255,0.95)";
      ctx.beginPath();
      ctx.moveTo(cx, cy-30);
      ctx.quadraticCurveTo(cx+6, cy-22, cx, cy-18);
      ctx.quadraticCurveTo(cx-6, cy-22, cx, cy-30);
      ctx.fill();
      ctx.restore();

      smallTag("WATR", cx, cy-6);
      drawPowerBadge(cx, topY-18, b.online);
      return;
    }

    // === TECH: purple comms node ===
    if(b.type==="tech"){
      const C="rgba(200,120,255,1)";
      halo(C, 0.11, 0.055);

      ctx.save(); ctx.globalAlpha=0.34; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.fillStyle="rgba(22,18,30,0.98)";
      ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(220,170,255,0.45)");

      ctx.fillStyle="rgba(120,70,170,0.95)";
      ctx.fillRect(cx-14, cy-40, 28, 26);
      outlineRect(cx-14, cy-40, 28, 26, "rgba(240,220,255,0.35)");

      // antenna
      ctx.strokeStyle="rgba(240,220,255,0.75)";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(cx, cy-52); ctx.lineTo(cx, cy-40);
      ctx.stroke();

      smallTag("TECH", cx, cy-6);
      drawPowerBadge(cx, topY-18, b.online);
      return;
    }

    // === HOUSING: bright neutral block (reads clearly) ===
    if(b.type==="house"){
      const C="rgba(255,255,255,1)";
      halo("rgba(255,255,255,1)", 0.08, 0.05);

      ctx.save(); ctx.globalAlpha=0.32; ctx.fillStyle="#000";
      ctx.beginPath(); ctx.ellipse(cx, cy-6, 22, 10, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.fillStyle="rgba(28,30,33,0.98)";
      ctx.fillRect(cx-18, cy-14, 36, 16);
      outlineRect(cx-18, cy-14, 36, 16, "rgba(255,255,255,0.25)");

      ctx.fillStyle="rgba(180,185,195,0.92)";
      ctx.fillRect(cx-14, cy-42, 28, 28);
      outlineRect(cx-14, cy-42, 28, 28, "rgba(255,255,255,0.45)");

      // windows
      ctx.fillStyle="rgba(40,45,55,0.8)";
      ctx.fillRect(cx-9, cy-34, 6, 6);
      ctx.fillRect(cx+3, cy-34, 6, 6);

      smallTag("HOME", cx, cy-6);
      drawPowerBadge(cx, topY-18, b.online);
      return;
    }

    // Fallback: keep existing card
    const w=64,h=38;
    roundRect(cx-w/2, topY, w, h, 10, true, true, "rgba(9,16,22,.92)", "rgba(255,255,255,.18)");

    ctx.fillStyle = b.online ? "rgba(255,255,255,.95)" : "rgba(214,222,230,.90)";
    ctx.font="11px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(shortLabel(b.type), cx, topY+14);

    ctx.fillStyle="rgba(214,222,230,.70)";
    ctx.font="10px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.fillText(b.online?"ONLINE":"OFFLINE", cx, topY+28);
  }


  function drawGhost(x,y,origin){
    const p=tileToScreen(x,y);
    const cx=origin.x+p.x, cy=origin.y+p.y;
    const w=64,h=38; const topY=cy-36;

    ctx.save();
    ctx.globalAlpha=0.55;
    roundRect(cx-w/2, topY, w, h, 10, true, true, "rgba(34,211,238,.10)", "rgba(34,211,238,.55)");
    ctx.fillStyle="rgba(34,211,238,.85)";
    ctx.font="10px ui-monospace, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText("PLACE", cx, topY+h/2);
    ctx.restore();
  }

  function drawSelectRing(x,y,origin){
    const p=tileToScreen(x,y);
    const cx=origin.x+p.x, cy=origin.y+p.y;
    ctx.save();
    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(34,211,238,.75)";
    ctx.beginPath();
    ctx.moveTo(cx, cy - TILE_H/2 + 2);
    ctx.lineTo(cx + TILE_W/2 - 2, cy);
    ctx.lineTo(cx, cy + TILE_H/2 - 2);
    ctx.lineTo(cx - TILE_W/2 + 2, cy);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  // Inputs
  el.btnStart.addEventListener("click", start);
  el.btnPause.addEventListener("click", pause);
  el.btnStep.addEventListener("click", step);
  el.btnReset.addEventListener("click", reset);
  el.btnStore.addEventListener("click", toggleStore);
  el.btnToggleOnline.addEventListener("click", toggleSelectedOnline);
  el.btnDelete.addEventListener("click", deleteSelected);
  el.btnCancelPlace.addEventListener("click", cancelPlacement);
  window.addEventListener("keydown",(e)=>{ if(e.key==="Escape") cancelPlacement(); });
function canvasPoint(e){
    const r=el.canvas.getBoundingClientRect();
    return {x:e.clientX-r.left, y:e.clientY-r.top};
  }
  function pickTile(px,py){
    const origin=boardOrigin();
    const bx=px-origin.x, by=py-origin.y;
    const raw=screenToTile(bx,by);
    const tx=Math.floor(raw.x+0.5), ty=Math.floor(raw.y+0.5);
    if(!inBounds(tx,ty)) return null;

    const center=tileToScreen(tx,ty);
    const cx=origin.x+center.x, cy=origin.y+center.y;
    const dx=Math.abs(px-cx)/(TILE_W/2);
    const dy=Math.abs(py-cy)/(TILE_H/2);
    if(dx+dy<=1.0) return {x:tx,y:ty};
    return null;
  }

  el.canvas.addEventListener("mousemove",(e)=>{
    const pt=canvasPoint(e);
    state.hoverTile = pickTile(pt.x,pt.y);
    draw();
  });
  el.canvas.addEventListener("mouseleave",()=>{ state.hoverTile=null; draw(); });

  el.canvas.addEventListener("click",(e)=>{
    const pt=canvasPoint(e);
    const tile=pickTile(pt.x,pt.y);
    if(!tile) return;
    const k=keyOf(tile.x,tile.y);
    const b=state.buildings.get(k);

    if(state.placingToken){
      if(b){ log("Tile occupied. Choose an empty tile."); return; }
      const type=state.placingToken.type;
      const item=CATALOG[type];
      if(item.oneOnly && isBuilt(state,type)){ log(`${item.name} is one-only and already built.`); state.placingToken=null; renderAll(); return; }

      const count=state.inventory.get(type)||0;
      if(count<=0){ log(`No ${item.name} tokens to place.`); state.placingToken=null; renderAll(); return; }
      state.inventory.set(type, count-1);

      setB({type, name:item.name, online:false, x:tile.x, y:tile.y});
      log(`Placed: ${item.name} @ ${tile.x},${tile.y} (OFFLINE)`);

      state.placingToken=null;
      renderAll();
      return;
    }

    if(b) selectKey(k);
    else clearSelection();
  });

  // Init
  function init(){
    reset();
    resizeCanvas();
    log("Loaded v0.2.1 (fuel + pop + taxes fix).");
    renderAll();
  }
  init();
})();

</script>
</body>
</html>
