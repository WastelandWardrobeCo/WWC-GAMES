<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Zone 13 — Power & Rations (Isometric Prototype v0)</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#121821;
    --text:#d7dee8;
    --muted:#8ea0b6;
    --green:#34d399;
    --yellow:#fbbf24;
    --red:#ef4444;
    --cyan:#60a5fa;
    --glow: 0 0 12px rgba(52,211,153,.25);
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
  .wrap{display:grid; grid-template-columns: 1fr 320px; gap:14px; padding:14px; height:100%; box-sizing:border-box;}
  .left{display:flex; flex-direction:column; gap:12px; min-width:0;}
  .topbar{display:grid; grid-template-columns: repeat(4, 1fr); gap:10px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);}
  .label{font-size:11px; letter-spacing:.08em; text-transform:uppercase; color:var(--muted);}
  .value{font-size:18px; font-weight:700; margin-top:3px;}
  .sub{font-size:11px; color:var(--muted); margin-top:2px;}
  .boardCard{flex:1; min-height:420px; position:relative; overflow:hidden;}
  canvas{width:100%; height:100%; display:block; border-radius:12px;}
  .hudBottom{
    position:absolute; left:14px; right:14px; bottom:14px;
    display:flex; gap:10px; align-items:center; justify-content:space-between;
    pointer-events:none;
  }
  .pill{pointer-events:auto; background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.10);
    border-radius:999px; padding:10px 12px; display:flex; gap:10px; align-items:center;
    box-shadow:0 12px 28px rgba(0,0,0,.35); backdrop-filter: blur(6px);}
  .pill small{color:var(--muted); font-size:11px;}
  input[type="range"]{width:180px;}
  .btn{pointer-events:auto; cursor:pointer; user-select:none; background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12); padding:10px 12px; border-radius:10px; font-weight:700;}
  .btn:hover{background:rgba(255,255,255,.09);}
  .side{display:flex; flex-direction:column; gap:12px;}
  .statusBig{display:flex; align-items:center; justify-content:space-between; gap:10px;}
  .badge{padding:8px 10px; border-radius:999px; font-weight:800; font-size:12px; letter-spacing:.04em;
    border:1px solid rgba(255,255,255,.14);}
  .badge.ok{color:var(--green); box-shadow: var(--glow);}
  .badge.bad{color:var(--red);}
  .badge.warn{color:var(--yellow);}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
  .log{height:220px; overflow:auto; background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.10);
    border-radius:10px; padding:10px; font-size:12px; color:#cbd5e1;}
  .log div{margin:2px 0;}
  .muted{color:var(--muted);}
  .divider{height:1px; background:rgba(255,255,255,.08); margin:8px 0;}
  .splash{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background: radial-gradient(1200px 700px at 30% 30%, rgba(52,211,153,.10), transparent 60%),
                radial-gradient(900px 600px at 75% 40%, rgba(96,165,250,.10), transparent 60%),
                rgba(0,0,0,.72);
    padding:18px;
  }
  .splash .box{
    width:min(860px, 96vw);
    background:linear-gradient(180deg, rgba(18,24,33,.98), rgba(10,14,20,.98));
    border:1px solid rgba(255,255,255,.10);
    border-radius:16px;
    box-shadow: 0 30px 80px rgba(0,0,0,.55);
    padding:18px 18px 14px;
  }
  .splash h1{margin:0 0 8px; font-size:18px; letter-spacing:.02em;}
  .splash p{margin:8px 0; color:#cbd5e1; line-height:1.45;}
  .splash ul{margin:10px 0 0 18px; color:#cbd5e1;}
  .splash li{margin:6px 0;}
  .splash .row{display:flex; gap:10px; justify-content:flex-end; margin-top:12px;}

    #helpBtn{width:44px; text-align:center; font-weight:800;}

</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div class="topbar">
      <div class="card">
        <div class="label">Power Reserve</div>
        <div class="value" id="powerReserve">+0.0 hr</div>
        <div class="sub" id="powerNet">(+0.0 net/hr)</div>
      </div>
      <div class="card">
        <div class="label">Food Reserve</div>
        <div class="value" id="foodReserve">+0.0 hr</div>
        <div class="sub" id="foodNet">(+0.0 net/hr)</div>
      </div>
      <div class="card">
        <div class="label">Habitability</div>
        <div class="value" id="habit">--%</div>
        <div class="sub">Life support integrity</div>
      </div>
      <div class="card">
        <div class="label">System Stability</div>
        <div class="value" id="stability">--%</div>
        <div class="sub" id="notice">Awaiting routing input…</div>
      </div>
    </div>

    <div class="card boardCard">
      <canvas id="board"></canvas>

      <div class="hudBottom">
        <div class="pill">
          <div class="mono" style="font-size:12px;">
            <div><span class="muted">Isometric v0:</span> click a port, then click a glowing target.</div>
            <div class="muted">Click the active port again to cancel. Reset clears all routing.</div>
          </div>
        </div>

        <div class="pill">
          <small class="muted">Harvester Throttle</small>
          <input id="throttle" type="range" min="0" max="100" value="60" />
          <div class="mono" id="throttlePct" style="width:44px; text-align:right;">60%</div>
        </div>

        <div class="btn" id="helpBtn">?</div>
        <div class="btn" id="resetBtn">Reset</div>
        <div class="btn" id="helpBtn" title="Help">?</div>
      </div>
    </div>
  </div>

  <div class="side">
    <div class="card statusBig">
      <div>
        <div class="label">System</div>
        <div class="value" id="systemTitle" style="font-size:16px;">Boot Sequence</div>
      </div>
      <div class="badge warn" id="systemBadge">INIT</div>
    </div>

    <div class="card">
      <div class="label">System Status</div>
      <div class="divider"></div>
      <div class="mono" style="font-size:12px; line-height:1.35;">
        <div><span class="muted">State:</span> <span id="stateLine">SYSTEM OFFLINE</span></div>
        <div><span class="muted">Life Support:</span> <span id="lifeLine">OFFLINE</span></div>
        <div><span class="muted">Harvester:</span> <span id="harvLine">OFFLINE</span></div>
      </div>
    </div>

    <div class="card">
      <div class="label">Harvester</div>
      <div class="divider"></div>
      <div class="mono" style="font-size:12px; line-height:1.35;">
        <div><span class="muted">Requested:</span> <span id="reqPct">60%</span></div>
        <div><span class="muted">Effective:</span> <span id="effPct">0%</span></div>
        <div><span class="muted">Harvesting:</span> <span id="harvRate">+0.000 / min</span></div>
        <div><span class="muted">Rations Stored:</span> <span id="rations">0.0000</span></div>
      </div>
    </div>

    <div class="card">
      <div class="label">Operator Log</div>
      <div class="divider"></div>
      <div class="log mono" id="log"></div>
    </div>
  </div>
</div>

<div class="splash" id="splash">
  <div class="box">
    <h1>ZONE 13: POWER &amp; RATIONS</h1>
    <p class="muted mono">Objective: restore Life Support, then power the Harvester. Throttle harvest to stay stable.</p>
    <ul>
      <li><b>Route Power:</b> Click a port, then click a <b>glowing</b> valid port to connect.</li>
      <li><b>Bring Life Support Online:</b> Without Life Support, the Harvester is disabled.</li>
      <li><b>Optimize Harvest:</b> Higher throttle yields rations faster but stresses relays and stability.</li>
    </ul>
    <p class="muted">Tip: Green cables indicate stable flow. If the system drops offline, re-route and recover.</p>
    <div class="row">
      <div class="btn" id="hideSplash">OK, START</div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const clamp = (v, a, b)=>Math.max(a, Math.min(b, v));
  const nowStamp = () => new Date().toTimeString().slice(0,8);
  const logEl = $("log");
  const pushLog = (msg) => {
    const line = document.createElement("div");
    line.textContent = `[${nowStamp()}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  };

  // Isometric layout settings. tileW/tileH are auto-sized per screen in resize().
  const ISO = { tileW:110, tileH:58, ox:0, oy:0,
    toScreen(gx, gy, gz=0){
      return { x:(gx-gy)*(this.tileW/2)+this.ox, y:(gx+gy)*(this.tileH/2)+this.oy-gz };
    }
  };

  const NODES = [
    // Layout tweak: spread the board so ports are easier to see/click.
    {id:'genA',  name:'Primary Generator A', type:'gen',   gx:2,  gy:7,  ports:2, supply:60},
    {id:'genB',  name:'Primary Generator B', type:'gen',   gx:2,  gy:11, ports:2, supply:60},
    {id:'aux',   name:'Auxiliary',           type:'aux',   gx:7,  gy:5,  ports:4, demand:15},
    {id:'relayA',name:'Relay A',             type:'relay', gx:7,  gy:9,  ports:4, cap:90},
    {id:'relayB',name:'Relay B',             type:'relay', gx:9,  gy:9,  ports:4, cap:72},
    {id:'harv',  name:'Food Harvester',      type:'harv',  gx:13, gy:6,  ports:2, baseDemand:30},
    {id:'life',  name:'Life Support',        type:'life',  gx:14, gy:12, ports:2, demand:55},
    {id:'gate',  name:'Sector Gate',         type:'gate',  gx:13, gy:9,  ports:0},
  ];
  const nodeById = Object.fromEntries(NODES.map(n=>[n.id,n]));

  let cables = [];
  let activePort = null;
  let rationsStored = 0.0;

  const portKey = (nid, pi) => `${nid}:p${pi}`;
  const parsePortKey = (k) => { const [nid,p]=k.split(":p"); return {nid, pi:Number(p)}; };
  const isPortUsed = (k)=>cables.some(c=>c.a===k||c.b===k);

  const allow = {
    gen: new Set(["relay","aux"]),
    aux: new Set(["relay"]),
    relay: new Set(["gen","relay","aux","life","harv"]),
    life: new Set(["relay"]),
    harv: new Set(["relay"]),
    gate: new Set([])
  };
  const typeAllows = (aType,bType)=> (allow[aType]?.has(bType) || allow[bType]?.has(aType));
  const canConnect = (aKey,bKey)=>{
    if(aKey===bKey) return false;
    if(isPortUsed(aKey)||isPortUsed(bKey)) return false;
    const a=parsePortKey(aKey), b=parsePortKey(bKey);
    const an=nodeById[a.nid], bn=nodeById[b.nid];
    if(!an||!bn) return false;
    if(an.ports<=a.pi||bn.ports<=b.pi) return false;
    if(an.type==='gate'||bn.type==='gate') return false;
    if(!typeAllows(an.type,bn.type)) return false;
    return true;
  };

  const adjacency = ()=>{
    const adj={}; NODES.forEach(n=>adj[n.id]=new Set());
    cables.forEach(c=>{
      const a=parsePortKey(c.a), b=parsePortKey(c.b);
      adj[a.nid].add(b.nid); adj[b.nid].add(a.nid);
    });
    return adj;
  };

  const reachableFromGens = ()=>{
    const adj=adjacency();
    const gens=NODES.filter(n=>n.type==='gen').map(n=>n.id);
    const vis=new Set(gens);
    const q=[...gens];
    while(q.length){
      const cur=q.shift();
      for(const nx of adj[cur]){
        if(!vis.has(nx)){ vis.add(nx); q.push(nx); }
      }
    }
    return vis;
  };
  const isConnectedToGens = (id)=>reachableFromGens().has(id);

  const computeStats = ()=>{
    const throttle=Number($("throttle").value)/100;
    const lifeOnline=isConnectedToGens('life');
    const systemOnline=lifeOnline;
    const harvPowered=systemOnline && isConnectedToGens('harv');

    const lifeDemand = lifeOnline ? nodeById.life.demand : 0;
    const auxDemand  = isConnectedToGens('aux') ? nodeById.aux.demand : 0;

    let supply=0;
    for(const g of NODES.filter(n=>n.type==='gen')){
      const active=cables.some(c=>parsePortKey(c.a).nid===g.id || parsePortKey(c.b).nid===g.id);
      if(active) supply+=g.supply;
    }

    let notice="System routing stable.";
    let effectiveThrottle=0;

    if(harvPowered && throttle>0){
      const harvLinkedToRelayB = cables.some(c=>{
        const a=parsePortKey(c.a), b=parsePortKey(c.b);
        return (a.nid==='harv'&&b.nid==='relayB')||(b.nid==='harv'&&a.nid==='relayB');
      });
      if(harvLinkedToRelayB){
        const baseDemand=lifeDemand+auxDemand;
        const remaining=Math.max(0, nodeById.relayB.cap - baseDemand);
        const requested=nodeById.harv.baseDemand*throttle;
        const effDemand=Math.min(requested, remaining);
        effectiveThrottle = effDemand / nodeById.harv.baseDemand;
        if(requested>remaining+0.001) notice="NOTICE: Throttle limited (relay capacity).";
      } else {
        effectiveThrottle=throttle;
      }
    }

    const harvDemand=harvPowered ? nodeById.harv.baseDemand*effectiveThrottle : 0;
    const demand=lifeDemand+auxDemand+harvDemand;

    const deficit=Math.max(0, demand - supply);
    const stability=clamp(100 - deficit*1.1, 0, 100);

    const powerNetPerHr=(supply-demand)/100;
    const powerReserveHr=clamp(0.2+powerNetPerHr, -9.9, 9.9);

    const foodNetPerHr = harvPowered ? (effectiveThrottle*1.5) : -0.7;
    const foodReserveHr=clamp(1.0+foodNetPerHr, -9.9, 9.9);

    const habit = lifeOnline ? clamp(70 + stability*0.3, 0, 100) : clamp(20 + stability*0.2, 0, 100);

    // Rations per minute at 100% effective. Higher value = more visible progress.
    // 1.0 feels "alive" even when effective throttle is low.
    const harvRate = harvPowered ? (effectiveThrottle * 1.000) : 0;

    return {systemOnline, lifeOnline, harvPowered, throttle, effectiveThrottle,
      stability, habit, powerReserveHr, powerNetPerHr, foodReserveHr, foodNetPerHr, harvRate, notice};
  };

  const canvas=$("board");
  const ctx=canvas.getContext("2d",{alpha:false});
  const pointer={x:0,y:0};

  const resize=()=>{
    const r=canvas.getBoundingClientRect();
    const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // Roominess pass: on large screens, increase spacing so ports aren't cramped.
    // On smaller screens, keep it tight enough that auto-fit can still keep everything visible.
    const base = Math.min(r.width * 0.82, r.height * 0.78);
    ISO.tileW = Math.max(92, Math.min(155, base / 5.6));
    ISO.tileH = ISO.tileW * 0.52;

    // Auto-fit: center all nodes in the available board area (prevents off-screen layouts).
    const rawToScreen=(gx,gy)=>({
      x:(gx-gy)*(ISO.tileW/2),
      y:(gx+gy)*(ISO.tileH/2)
    });
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const n of NODES){
      const p=rawToScreen(n.gx,n.gy);
      minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
      minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    }
    const cx=(minX+maxX)/2, cy=(minY+maxY)/2;

    // Leave room for the bottom HUD and right panel; bias slightly left/up.
    const usableW=r.width * 0.82;   // right panel takes ~18%
    const usableH=r.height * 0.78;  // bottom HUD takes ~22%
    const targetX=(usableW/2);
    const targetY=(usableH/2);

    ISO.ox = targetX - cx + 20;
    ISO.oy = targetY - cy + 40;
  };
  window.addEventListener("resize", resize);

  const drawGrid=(w,h)=>{
    ctx.save();
    ctx.globalAlpha=0.12;
    ctx.strokeStyle="rgba(255,255,255,.10)";
    ctx.lineWidth=1;
    for(let gx=-2; gx<18; gx++){
      const a=ISO.toScreen(gx,-2), b=ISO.toScreen(gx,16);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    for(let gy=-2; gy<18; gy++){
      const a=ISO.toScreen(-2,gy), b=ISO.toScreen(16,gy);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.restore();
  };

  const nodeSortKey=(n)=>n.gx+n.gy;

  const nodeTint=(t)=>{
    if(t==='gen') return {top:"#1f2a3a", side:"#151e2a", edge:"rgba(96,165,250,.35)"};
    if(t==='relay') return {top:"#262d38", side:"#171d26", edge:"rgba(251,191,36,.35)"};
    if(t==='life') return {top:"#22302b", side:"#151f1c", edge:"rgba(52,211,153,.35)"};
    if(t==='harv') return {top:"#262834", side:"#151620", edge:"rgba(52,211,153,.25)"};
    if(t==='aux') return {top:"#2a2733", side:"#171522", edge:"rgba(167,139,250,.30)"};
    return {top:"#222", side:"#111", edge:"rgba(255,255,255,.18)"};
  };

  const drawIsoBlock=(cx,cy,w,h,height,tint)=>{
    const hw=w/2, hh=h/2;
    const top=[
      {x:cx,y:cy-height},{x:cx+hw,y:cy-height+hh},{x:cx,y:cy-height+h},{x:cx-hw,y:cy-height+hh}
    ];
    const left=[
      {x:cx-hw,y:cy-height+hh},{x:cx,y:cy-height+h},{x:cx,y:cy+h},{x:cx-hw,y:cy+hh}
    ];
    const right=[
      {x:cx+hw,y:cy-height+hh},{x:cx,y:cy-height+h},{x:cx,y:cy+h},{x:cx+hw,y:cy+hh}
    ];
    ctx.save();
    ctx.fillStyle=tint.side;
    ctx.beginPath(); ctx.moveTo(left[0].x,left[0].y); left.slice(1).forEach(p=>ctx.lineTo(p.x,p.y)); ctx.closePath(); ctx.fill();
    ctx.globalAlpha=0.92;
    ctx.beginPath(); ctx.moveTo(right[0].x,right[0].y); right.slice(1).forEach(p=>ctx.lineTo(p.x,p.y)); ctx.closePath(); ctx.fill();
    ctx.globalAlpha=1;
    ctx.fillStyle=tint.top;
    ctx.beginPath(); ctx.moveTo(top[0].x,top[0].y); top.slice(1).forEach(p=>ctx.lineTo(p.x,p.y)); ctx.closePath(); ctx.fill();

    ctx.strokeStyle=tint.edge; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(top[0].x,top[0].y); top.slice(1).forEach(p=>ctx.lineTo(p.x,p.y)); ctx.closePath(); ctx.stroke();
    ctx.strokeStyle="rgba(255,255,255,.08)"; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(top[0].x,top[0].y); top.slice(1).forEach(p=>ctx.lineTo(p.x,p.y)); ctx.closePath(); ctx.stroke();
    ctx.restore();
  };

  const getNodeRect=(n)=>{
    const base=ISO.toScreen(n.gx,n.gy,0);
    const w=(n.type==='relay')?120:(n.type==='harv'?150:130);
    const h=72, height=22;
    return {cx:base.x, cy:base.y-10, w, h, height};
  };

  const portScreenPos=(n,pi)=>{
    const r=getNodeRect(n);

    // Relays: 4 ports, one per corner for clarity (purely visual/hitbox positioning).
    if(n.type==='relay' && n.ports===4){
      const padX=16;
      const padY=18;
      const topY=-r.height+padY;
      const botY=-r.height+padY+34;
      const corners=[
        {x:-r.w/2+padX, y:topY},   // NW
        {x: r.w/2-padX, y:topY},   // NE
        {x: r.w/2-padX, y:botY},   // SE
        {x:-r.w/2+padX, y:botY},   // SW
      ];
      const o=corners[pi]||corners[0];
      return {x:r.cx+o.x, y:r.cy+o.y};
    }

    // Default: split ports along left/right edges.
    const offs=[];
    for(let i=0;i<Math.ceil(n.ports/2);i++) offs.push({x:-r.w/2+14, y:-r.height+22+i*18});
    for(let i=0;i<Math.floor(n.ports/2);i++) offs.push({x:r.w/2-14, y:-r.height+22+i*18});
    const o=offs[pi]||offs[0]||{x:0,y:0};
    return {x:r.cx+o.x, y:r.cy+o.y};
  };

  const drawPort=(n,pi,stats)=>{
    const k=portKey(n.id,pi);
    const used=isPortUsed(k);
    const pos=portScreenPos(n,pi);
    const isActive=activePort===k;
    let isValid=false;
    if(activePort && activePort!==k) isValid=canConnect(activePort,k);
    const rad=9;
    ctx.save();
    ctx.lineWidth=2.2;
    let ring="rgba(255,255,255,.20)";
    if(used) ring="rgba(255,255,255,.10)";
    if(isValid) ring="rgba(52,211,153,.90)";
    if(isActive) ring="rgba(96,165,250,.95)";
    ctx.strokeStyle=ring;
    ctx.fillStyle=used?"rgba(0,0,0,.40)":"rgba(0,0,0,.25)";
    ctx.beginPath(); ctx.arc(pos.x,pos.y,rad,0,Math.PI*2); ctx.fill(); ctx.stroke();
    if(isValid){
      ctx.shadowColor="rgba(52,211,153,.55)"; ctx.shadowBlur=18;
      ctx.strokeStyle="rgba(52,211,153,1)";
      ctx.beginPath(); ctx.arc(pos.x,pos.y,rad+1.5,0,Math.PI*2); ctx.stroke();
    }
    if(isActive){
      ctx.shadowColor="rgba(96,165,250,.55)"; ctx.shadowBlur=18;
      ctx.strokeStyle="rgba(96,165,250,1)";
      ctx.beginPath(); ctx.arc(pos.x,pos.y,rad+1.5,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  };

  const cableColor=(stats)=>{
    if(!stats.systemOnline) return "rgba(148,163,184,.35)";
    if(stats.stability>=80) return "rgba(52,211,153,.95)";
    if(stats.stability>=55) return "rgba(251,191,36,.95)";
    return "rgba(239,68,68,.95)";
  };

  const drawCable=(aKey,bKey,stats)=>{
    const a=parsePortKey(aKey), b=parsePortKey(bKey);
    const an=nodeById[a.nid], bn=nodeById[b.nid];
    if(!an||!bn) return;
    const p1=portScreenPos(an,a.pi), p2=portScreenPos(bn,b.pi);
    const mx=(p1.x+p2.x)/2, my=(p1.y+p2.y)/2 - 18;
    ctx.save();
    const col=cableColor(stats);
    ctx.lineWidth=6; ctx.lineCap="round"; ctx.strokeStyle=col;
    ctx.shadowColor=col; ctx.shadowBlur=14;
    ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.quadraticCurveTo(mx,my,p2.x,p2.y); ctx.stroke();
    ctx.shadowBlur=0;
    ctx.lineWidth=2.5; ctx.strokeStyle="rgba(255,255,255,.14)";
    ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.quadraticCurveTo(mx,my,p2.x,p2.y); ctx.stroke();
    ctx.restore();
  };

  const drawNode=(n,stats)=>{
    const r=getNodeRect(n);
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.beginPath();
    ctx.ellipse(r.cx, r.cy + r.h/2 + 18, r.w*0.32, 14, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    drawIsoBlock(r.cx,r.cy,r.w,r.h,r.height,nodeTint(n.type));

    ctx.save();
    ctx.font="700 13px ui-sans-serif, system-ui";
    ctx.fillStyle="rgba(215,222,232,.92)";
    ctx.textAlign="center";
    ctx.fillText(n.name, r.cx, r.cy - r.height + r.h + 18);
    ctx.font="12px ui-monospace, Menlo, Consolas, monospace";
    ctx.fillStyle="rgba(142,160,182,.95)";
    if(n.type==='gen') ctx.fillText(`Supply: ${n.supply}`, r.cx, r.cy - r.height + r.h + 35);
    else if(n.type==='relay') ctx.fillText(`Capacity: ${n.cap}`, r.cx, r.cy - r.height + r.h + 35);
    else if(n.type==='life') ctx.fillText(`Demand: ${n.demand}`, r.cx, r.cy - r.height + r.h + 35);
    else if(n.type==='harv'){
      const req=Math.round(stats.throttle*100);
      const load=(stats.systemOnline && stats.harvPowered)?Math.round(n.baseDemand*stats.effectiveThrottle):0;
      ctx.fillText(`Load: ${load} / ${n.baseDemand}  (Req ${req}%)`, r.cx, r.cy - r.height + r.h + 35);
    } else if(n.type==='aux') ctx.fillText("Aux-link", r.cx, r.cy - r.height + r.h + 35);
    else if(n.type==='gate') ctx.fillText("INACTIVE", r.cx, r.cy - r.height + r.h + 35);
    ctx.restore();

    for(let i=0;i<n.ports;i++) drawPort(n,i,stats);
  };

  const draw=()=>{
    const r=canvas.getBoundingClientRect();
    ctx.save();
    ctx.fillStyle="#0b0f14";
    ctx.fillRect(0,0,r.width,r.height);

    const vg=ctx.createRadialGradient(r.width*0.45,r.height*0.45,80,r.width*0.55,r.height*0.55,Math.max(r.width,r.height));
    vg.addColorStop(0,"rgba(255,255,255,.03)");
    vg.addColorStop(1,"rgba(0,0,0,.35)");
    ctx.fillStyle=vg; ctx.fillRect(0,0,r.width,r.height);

    drawGrid(r.width,r.height);

    const stats=computeStats();

    for(const c of cables) drawCable(c.a,c.b,stats);

    if(activePort){
      const ap=parsePortKey(activePort);
      const an=nodeById[ap.nid];
      if(an){
        const p1=portScreenPos(an,ap.pi);
        ctx.save();
        ctx.lineWidth=3.5; ctx.setLineDash([6,6]);
        ctx.strokeStyle="rgba(96,165,250,.65)";
        ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(pointer.x,pointer.y); ctx.stroke();
        ctx.restore();
      }
    }

    [...NODES].sort((a,b)=>nodeSortKey(a)-nodeSortKey(b)).forEach(n=>drawNode(n,stats));

    ctx.save();
    ctx.font="900 16px ui-sans-serif, system-ui";
    ctx.textAlign="right";
    ctx.fillStyle=stats.systemOnline?"rgba(52,211,153,.95)":"rgba(239,68,68,.92)";
    ctx.fillText(stats.systemOnline?"SYSTEM ONLINE":"SYSTEM OFFLINE", r.width-18, 34);
    ctx.restore();

    ctx.restore();
  };

  const canvasToLocal=(ev)=>{
    const r=canvas.getBoundingClientRect();
    return {x:ev.clientX-r.left, y:ev.clientY-r.top};
  };

  const allPorts=()=>{
    const out=[];
    for(const n of NODES){
      for(let i=0;i<n.ports;i++){
        const pos=portScreenPos(n,i);
        out.push({k:portKey(n.id,i), x:pos.x, y:pos.y});
      }
    }
    return out;
  };
  const hitPort=(x,y)=>{
    let best=null, bestD=1e9;
    for(const p of allPorts()){
      const dx=p.x-x, dy=p.y-y;
      const d=Math.hypot(dx,dy);
      if(d<16 && d<bestD){ best=p; bestD=d; }
    }
    return best;
  };

  const connect=(a,b)=>{
    cables.push({a,b});
    pushLog(`Cable connected: ${a} -> ${b}`);
  };

  const reset=()=>{
    cables=[]; activePort=null; rationsStored=0.0;
    pushLog("System reset: all routing cleared.");
  };

  canvas.addEventListener("mousemove",(ev)=>{
    const p=canvasToLocal(ev);
    pointer.x=p.x; pointer.y=p.y;
  });

  canvas.addEventListener("click",(ev)=>{
    const p=canvasToLocal(ev);
    pointer.x=p.x; pointer.y=p.y;
    const hit=hitPort(p.x,p.y);
    if(!hit){
      if(activePort){ activePort=null; pushLog("Routing selection cleared."); }
      return;
    }
    if(isPortUsed(hit.k)){
      // Disconnect QoL: click an occupied port (when not actively routing) to remove its cable.
      // This keeps iteration fast and prevents "permanent" mistakes.
      if(!activePort){
        const before = cables.length;
        cables = cables.filter(c => !(c.a===hit.k || c.b===hit.k));
        const removed = before - cables.length;
        if(removed>0) pushLog(`Cable removed from: ${hit.k}`);
        return;
      }
      // If currently routing, keep selection; occupied ports cannot accept new connections.
      pushLog("Port is occupied.");
      return;
    }

    if(!activePort){
      activePort=hit.k; pushLog(`Selected port: ${hit.k}`); return;
    }
    if(activePort===hit.k){ activePort=null; pushLog("Selection cancelled."); return; }
    if(canConnect(activePort, hit.k)){ connect(activePort, hit.k); activePort=null; return; }

    activePort=hit.k; pushLog(`Selected port: ${hit.k}`);
  });

  $("resetBtn").addEventListener("click", reset);

  // Help re-opens splash anytime
  const helpBtn = $("helpBtn");
  if(helpBtn){ helpBtn.addEventListener("click", ()=>{ splash.style.display="flex"; }); }

  $("helpBtn").addEventListener("click", ()=>openSplash());

  const setBadge=(kind,text)=>{
    const b=$("systemBadge");
    b.classList.remove("ok","bad","warn");
    if(kind==="ok") b.classList.add("ok");
    if(kind==="bad") b.classList.add("bad");
    if(kind==="warn") b.classList.add("warn");
    b.textContent=text;
  };

  const fmt=(n,d=1)=>{
    const s=(Math.round(n*Math.pow(10,d))/Math.pow(10,d)).toFixed(d);
    return (n>=0?"+":"")+s;
  };

  const renderHUD=(s)=>{
    $("throttlePct").textContent=`${Math.round(s.throttle*100)}%`;
    $("reqPct").textContent=`${Math.round(s.throttle*100)}%`;
    $("effPct").textContent=`${Math.round(s.effectiveThrottle*100)}%`;

    $("powerReserve").textContent=`${fmt(s.powerReserveHr,1)} hr`;
    $("powerNet").textContent=`(${fmt(s.powerNetPerHr,2)} net/hr)`;
    $("foodReserve").textContent=`${fmt(s.foodReserveHr,1)} hr`;
    $("foodNet").textContent=`(${fmt(s.foodNetPerHr,2)} net/hr)`;

    $("habit").textContent=`${Math.round(s.habit)}%`;
    $("stability").textContent=`${Math.round(s.stability)}%`;
    $("notice").textContent=s.notice;

    // Extra precision makes the "stopwatch" feel, especially at low throttle.
    $("rations").textContent=rationsStored.toFixed(4);
    $("harvRate").textContent=`+${s.harvRate.toFixed(3)} / min`;

    if(s.systemOnline){
      $("systemTitle").textContent="System Healthy";
      setBadge("ok","ONLINE");
      $("stateLine").textContent="SYSTEM ONLINE";
      $("lifeLine").textContent="ONLINE";
    } else {
      $("systemTitle").textContent="System Critical";
      setBadge("bad","OFFLINE");
      $("stateLine").textContent="SYSTEM OFFLINE";
      $("lifeLine").textContent="OFFLINE";
    }

    if(s.systemOnline && s.harvPowered && s.effectiveThrottle>0){
      $("harvLine").textContent = (s.effectiveThrottle < s.throttle) ? `THROTTLED (${Math.round(s.effectiveThrottle*100)}%)` : "ONLINE";
    } else {
      $("harvLine").textContent="OFFLINE";
    }
  };

  let lastT=performance.now();
  const tick=(t)=>{
    const dt=(t-lastT)/1000; lastT=t;
    const s=computeStats();
    if(s.systemOnline && s.harvPowered && s.harvRate>0){
      rationsStored += (s.harvRate/60)*dt;
    }
    renderHUD(s);
    draw();
    requestAnimationFrame(tick);
  };

  const splash=$("splash");
  const KEY="zone13_iso_splash_seen_v0_5";
  const showSplash=()=>{ splash.style.display="flex"; };
  const hideSplash=()=>{ splash.style.display="none"; try{localStorage.setItem(KEY,"1");}catch(e){} };
  $("hideSplash").addEventListener("click", hideSplash);
  window.addEventListener("keydown",(ev)=>{ if(ev.key==="Escape" && splash.style.display==="flex") hideSplash(); });

  const init=()=>{
    resize();
    pushLog("Boot sequence loaded. Awaiting routing input…");
    pushLog("Tip: Click a port, then click a glowing target port.");
    try{ if(localStorage.getItem(KEY)!=="1") showSplash(); }catch(e){ showSplash(); }
    requestAnimationFrame(tick);
  };
  init();
})();
</script>
</body>
</html>
