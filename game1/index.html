<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Zone 13 - Power & Rations (v2.0)</title>
  <style>
    :root{
      --bg:#0d0f12;
      --panel:#171a1f;
      --panel2:#12151a;
      --stroke:#2a303a;
      --text:#cfd6df;
      --muted:#8b97a6;

      --good:#58d68d;
      --warn:#f4d03f;
      --bad:#ff5c5c;
      --cold:#69b7ff;
      --food:#b58bff;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      -webkit-text-size-adjust:100%;
    }
    body{overscroll-behavior:none;touch-action:manipulation;}
    .wrap{max-width:1150px;margin:0 auto;padding:14px 14px 18px;}
    .topbar{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr 1fr auto;
      gap:10px; align-items:center;
      padding:12px 12px;
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid var(--stroke);
      border-radius:12px;
      box-shadow: 0 8px 25px rgba(0,0,0,.35);
      position:sticky; top:0; z-index:5;
    }
    .stat{
      display:flex; flex-direction:column; gap:2px;
      padding:8px 10px;
      border:1px solid var(--stroke);
      border-radius:10px;
      background:rgba(0,0,0,.2);
      min-height:44px;
    }
    .label{font-size:12px;color:var(--muted);letter-spacing:.08em;text-transform:uppercase}
    .value{font-size:18px;font-weight:650}
    .value small{font-size:12px;color:var(--muted);font-weight:600}
    .notice{justify-self:end;display:flex;gap:8px;align-items:center;}
    .pill{
      padding:8px 10px;border-radius:999px;border:1px solid var(--stroke);
      background:rgba(0,0,0,.22);
      font-size:12px;color:var(--muted);
      user-select:none;
      max-width:340px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .btn{padding:9px 12px;border-radius:10px;border:1px solid var(--stroke);
      background:#0f1216;color:var(--text);cursor:pointer;font-weight:650;}
    .btn:hover{filter:brightness(1.08)}
    .main{margin-top:12px;display:grid;grid-template-columns:1fr;gap:12px;}
    .card{
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid var(--stroke);
      border-radius:14px;
      box-shadow: 0 10px 35px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .canvasWrap{
      position:relative;
      background:
        radial-gradient(1000px 600px at 30% 10%, rgba(88,214,141,.08), transparent 55%),
        radial-gradient(900px 600px at 80% 30%, rgba(105,183,255,.06), transparent 60%),
        radial-gradient(900px 600px at 50% 90%, rgba(181,139,255,.06), transparent 60%),
        linear-gradient(180deg, #0e1116, #0b0d10);
    }
    canvas{
      display:block;
      width:100%;
      height:auto;
      touch-action:none; /* critical for iPhone Safari */
      -webkit-user-select:none;
      user-select:none;
    }
    .bottomPanel{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px; align-items:start;
      padding:12px 12px;
      border-top:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
    }
    .hint{color:var(--muted);font-size:13px;line-height:1.25}
    .hint b{color:var(--text)}
    .rightInfo{display:flex;gap:10px;align-items:center;justify-content:flex-end;flex-wrap:wrap;}
    .tag{
      font-size:12px;color:var(--muted);
      padding:7px 9px;border:1px solid var(--stroke);border-radius:999px;background:rgba(0,0,0,.22);
      user-select:none; white-space:nowrap;
    }
    .danger{color:var(--bad)}
    .good{color:var(--good)}
    .warn{color:var(--warn)}
    .cold{color:var(--cold)}
    .food{color:var(--food)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .footer{margin-top:8px;color:var(--muted);font-size:12px;text-align:center;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="stat">
      <div class="label">Power Reserve</div>
      <div class="value" id="powerReserve">+0.0 hr <small>(net)</small></div>
    </div>
    <div class="stat">
      <div class="label">Food Reserve</div>
      <div class="value" id="foodReserve">+0.0 hr <small>(net)</small></div>
    </div>
    <div class="stat">
      <div class="label">Habitability</div>
      <div class="value" id="habitPct">100%</div>
    </div>
    <div class="stat">
      <div class="label">System Stability</div>
      <div class="value" id="stabilityPct">100%</div>
    </div>
    <div class="notice">
      <div class="pill" id="noticePill">NO ACTIVE NOTICES</div>
      <button class="btn" id="resetBtn" title="Resets save + connections">Reset</button>
    </div>
  </div>

  <div class="main">
    <div class="card">
      <div class="canvasWrap">
        <canvas id="c"></canvas>
      </div>
      <div class="bottomPanel">
        <div class="hint">
          <b>Power & Rations</b> · Drag cable ends, or tap mode:
          <span class="mono">tap an endpoint</span> → <span class="mono">tap a port</span>.
          <span style="display:block;margin-top:8px" id="projLine" class="mono">Projection: --</span>
          <span style="display:block;margin-top:6px">
            Food Harvester converts power into rations. Low rations reduce Habitability. Low Habitability slows stability recovery.
          </span>
        </div>
        <div class="rightInfo">
          <div class="tag" id="tagObjective">Objective: <span class="muted">Survive heat events</span></div>
          <div class="tag" id="tagHeat">Heat: <span class="muted">--</span></div>
          <div class="tag" id="tagHover">Hover: <span class="muted">None</span></div>
          <div class="tag" id="tagMode">Mode: <span class="muted">Idle</span></div>
          <div class="tag" id="tagTime">Offline: <span class="muted">0s</span></div>
        </div>
      </div>
    </div>

    <div class="footer">
      Zone 13 (v2.0) · Food Harvester machine · Touch-safe routing · Offline progress · Local save
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- helpers ----------
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // ---------- canvas ----------
  const canvas=document.getElementById('c');
  const ctx=canvas.getContext('2d',{alpha:false});
  function resizeCanvas(){
    const cssW=canvas.clientWidth;
    const cssH=Math.round(cssW*0.62);
    const dpr=Math.min(window.devicePixelRatio||1,2);
    canvas.style.height=cssH+'px';
    canvas.width=Math.floor(cssW*dpr);
    canvas.height=Math.floor(cssH*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize',resizeCanvas);
  resizeCanvas();

  // ---------- model ----------
  const MODEL_VERSION=3;
  const SAVE_KEY="zone13_v2_save";

  const state={
    version:MODEL_VERSION,
    tLast:Date.now(),

    // reserves are in "units", later converted to "hours" via current demand/consumption rates
    powerReserveUnits:30,          // reserve in power-units
    foodReserveUnits:40,           // reserve in food-units

    stability:0.84,                // 0..1
    habitability:0.88,             // 0..1

    hover:null,
    dragging:null,
    tapPick:null,
    notice:"NO ACTIVE NOTICES",

    gateAnomaly:false,

    // Heat anomaly system
    heat:{
      active:false,
      target:"relayB",
      reduction:0.35,
      untilMs:0,
      nextMs:Date.now()+90_000,

      // Objective tracking: survive 3 heat events without losing life support DURING heat
      progress:0,           // 0..3
      inEventHadLife:true,  // tracked during active heat
      completed:false
    }
  };

  // Nodes
  // IMPORTANT: Food Harvester is a MACHINE node (consumer+producer)
  const nodes=[
    { id:"genA", name:"Primary Generator A", kind:"generator", x:160, y:220, supply:55, ports:[[-26,0],[26,0]] },
    { id:"genB", name:"Primary Generator B", kind:"generator", x:160, y:360, supply:55, ports:[[-26,0],[26,0]] },

    { id:"relayA", name:"Relay A", kind:"relay", x:420, y:300, relayCapacity:85, ports:[[-32,-14],[-32,14],[32,-14],[32,14]] },
    { id:"relayB", name:"Relay B", kind:"relay", x:560, y:260, relayCapacity:70, ports:[[-32,0],[32,0],[0,32]] },

    { id:"harv", name:"Food Harvester", kind:"harvester", x:720, y:130,
      powerDemand:30, foodOutput:28, ports:[[-32,0],[32,0],[0,32]] },

    { id:"aux",  name:"Auxiliary", kind:"consumer", x:420, y:150, demand:22, ports:[[0,30],[0,-30],[30,0],[-30,0]] },
    { id:"life", name:"Life Support", kind:"consumer", x:820, y:330, demand:58, ports:[[-32,0],[32,0],[0,-32]] },
    { id:"gate", name:"Sector Gate (LOCKED)", kind:"gate", x:930, y:220, demand:0, ports:[[-34,0],[0,34]], locked:true },
  ];

  // Links (wiring)
  const links=[
    { id:"L1", a:{node:"genA",port:1},  b:{node:"relayA",port:0} },
    { id:"L2", a:{node:"genB",port:1},  b:{node:"relayA",port:1} },
    { id:"L3", a:{node:"relayA",port:2}, b:{node:"relayB",port:0} },
    { id:"L4", a:{node:"relayA",port:3}, b:{node:"aux",port:3} },
    { id:"L5", a:{node:"relayB",port:1}, b:{node:"life",port:0} },
    { id:"L6", a:{node:"relayB",port:2}, b:{node:"gate",port:0} },
    // v2 adds harvester wiring line by default (from Relay B side)
    { id:"L7", a:{node:"relayB",port:0}, b:{node:"harv",port:0} },
  ];

  const hit={ nodeRadius:28, portRadius:12 };
  const getNode=(id)=>nodes.find(n=>n.id===id);
  function portWorldPos(node,portIndex){
    const [dx,dy]=node.ports[portIndex];
    return {x:node.x+dx,y:node.y+dy};
  }

  // ---------- graph ----------
  function buildGraph(localLinks){
    const adj=new Map();
    for(const n of nodes) adj.set(n.id,[]);
    for(const L of localLinks){
      adj.get(L.a.node).push(L.b.node);
      adj.get(L.b.node).push(L.a.node);
    }
    return adj;
  }
  function bfsPath(adj,start,goal){
    const q=[start];
    const prev=new Map();
    prev.set(start,null);
    while(q.length){
      const cur=q.shift();
      if(cur===goal) break;
      for(const nxt of adj.get(cur)||[]){
        if(!prev.has(nxt)){
          prev.set(nxt,cur);
          q.push(nxt);
        }
      }
    }
    if(!prev.has(goal)) return null;
    const path=[];
    let cur=goal;
    while(cur!==null){ path.push(cur); cur=prev.get(cur); }
    path.reverse();
    return path;
  }

  // ---------- heat (anomaly + objective) ----------
  function baseHeatIntervalMs(){
    // Habitability makes heat more frequent when low, less when high.
    // 0.90+ habit => slower, 0.60 habit => faster
    const h = state.habitability;
    const scale = clamp(1.25 - (h-0.6)*0.9, 0.75, 1.35);
    return Math.round(150_000 * scale); // around 2.5 minutes baseline
  }

  function updateHeat(nowMs){
    const H = state.heat;

    // End event
    if(H.active && nowMs >= H.untilMs){
      // event ends: if life stayed powered throughout event => progress++
      if(H.inEventHadLife){
        H.progress = clamp(H.progress + 1, 0, 3);
        if(H.progress >= 3){
          H.completed = true;
          state.notice = "OBJECTIVE COMPLETE: EVENT SURVIVAL CONFIRMED";
        }
      } else {
        // failure resets progress (harsh but clean, as designed)
        H.progress = 0;
      }
      H.active=false;

      // schedule next heat
      const jitter = Math.floor(Math.random()*60_000);
      H.nextMs = nowMs + baseHeatIntervalMs() + jitter;
      H.inEventHadLife = true;
    }

    // Start event
    if(!H.active && nowMs >= H.nextMs){
      H.active=true;
      H.target = (Math.random() < 0.75) ? "relayB" : "relayA";
      H.reduction = (H.target==="relayB") ? 0.35 : 0.28;
      const dur = 70_000 + Math.floor(Math.random()*55_000);
      H.untilMs = nowMs + dur;
      H.inEventHadLife = true;
    }
  }

  function effectiveRelayCapacity(relayId, nowMs){
    const n=getNode(relayId);
    if(!n||n.kind!=="relay") return 0;
    const base=n.relayCapacity||0;
    const H=state.heat;
    if(H.active && relayId===H.target && nowMs < H.untilMs){
      return Math.max(10, Math.round(base*(1-H.reduction)));
    }
    return base;
  }

  // ---------- compute ----------
  function computeFor(sim, localLinks, nowMs){
    const adj=buildGraph(localLinks);
    const gens=nodes.filter(n=>n.kind==="generator");
    const consumers=nodes.filter(n=>n.kind==="consumer");
    const gate=getNode("gate");
    const harv=getNode("harv");

    function pass(gateDemandUnits){
      gate.demand = gateDemandUnits;

      // Treat harvester like a consumer for power-serving purposes
      const allConsumers=[...consumers, harv, gate];

      const supply = gens.reduce((s,g)=>s+g.supply,0);
      let servedDemand=0;

      const served=new Map(); // id -> {served, path}
      for(const c of allConsumers){
        if(c.id==="gate" && c.locked && gateDemandUnits<=0){
          served.set(c.id,{served:false,path:null});
          continue;
        }
        // demand varies by kind
        const demand = (c.kind==="harvester") ? (c.powerDemand||0) : (c.demand||0);

        let found=null;
        for(const g of gens){
          const p=bfsPath(adj,g.id,c.id);
          if(p){ found=p; break; }
        }
        const ok=!!found;
        served.set(c.id,{served:ok,path:found});
        if(ok) servedDemand += demand;
      }

      const relayLoads=new Map();
      for(const r of nodes.filter(n=>n.kind==="relay")) relayLoads.set(r.id,0);

      for(const c of allConsumers){
        const info=served.get(c.id);
        if(!info?.served) continue;

        const demand = (c.kind==="harvester") ? (c.powerDemand||0) : (c.demand||0);
        for(const nodeId of info.path){
          const n=getNode(nodeId);
          if(n?.kind==="relay"){
            relayLoads.set(nodeId, relayLoads.get(nodeId) + demand);
          }
        }
      }

      const loadPct = supply>0 ? servedDemand/supply : 0;
      return { supply, servedDemand, served, relayLoads, loadPct };
    }

    // Pass 1 (no gate draw)
    let res = pass(0);

    const capA = effectiveRelayCapacity("relayA", nowMs);
    const capB = effectiveRelayCapacity("relayB", nowMs);
    const loadA = res.relayLoads.get("relayA")||0;
    const loadB = res.relayLoads.get("relayB")||0;
    const relayAOver = loadA > capA;
    const relayBOver = loadB > capB;

    // gate stress uses stability + overload
    const stress = (relayBOver ? 0.25 : 0) + clamp((0.78 - sim.stability)*1.2, 0, 0.35);
    const gateDemand = stress>0 ? Math.round(18 + 40*stress) : 0;

    // Pass 2 (with gate draw)
    res = pass(gateDemand);

    const loadA2 = res.relayLoads.get("relayA")||0;
    const loadB2 = res.relayLoads.get("relayB")||0;
    const relayAOver2 = loadA2 > capA;
    const relayBOver2 = loadB2 > capB;

    const servedLife = res.served.get("life")?.served ?? false;

    // Harvester power status
    const harvPowered = res.served.get("harv")?.served ?? false;

    // Harvester efficiency: depends on stability and overloads
    const overloadPenalty = (relayAOver2||relayBOver2) ? 0.65 : 1.0;
    const stabilityFactor = clamp((sim.stability - 0.45) / 0.55, 0, 1); // 0 at 0.45, 1 at 1.0
    const habitFactor = clamp((sim.habitability - 0.55) / 0.45, 0.65, 1.0); // low habit reduces output a bit
    const harvEff = harvPowered ? (0.25 + 0.75*stabilityFactor) * overloadPenalty * habitFactor : 0;

    const harvFoodOutPerHr = (harv.foodOutput||0) * harvEff;

    // Notices (priority order)
    let notice = "NO ACTIVE NOTICES";
    if(res.loadPct > 0.95) notice = "WARNING: POWER DEFICIT";
    if(relayBOver2) notice = "WARNING: RELAY B OVERLOAD";
    if(relayAOver2) notice = "WARNING: RELAY A OVERLOAD";
    if(!servedLife) notice = "CRITICAL: LIFE SUPPORT UNPOWERED";
    if(!harvPowered && notice === "NO ACTIVE NOTICES") notice = "NOTICE: HARVESTER UNPOWERED";
    if(harvPowered && harvEff < 0.55 && notice === "NO ACTIVE NOTICES") notice = "NOTICE: HARVESTER THROTTLED (EFFICIENCY)";
    if(gateDemand>0 && notice === "NO ACTIVE NOTICES") notice = "NOTICE: GATE DRAW DETECTED";

    return {
      ...res,
      notice,
      relayAOver: relayAOver2,
      relayBOver: relayBOver2,
      capA, capB,
      gateDemand,
      harvPowered,
      harvEff,
      harvFoodOutPerHr
    };
  }

  // ---------- progression tick ----------
  function tick(dtSeconds){
    const nowMs=Date.now();
    updateHeat(nowMs);

    const sim = {
      powerReserveUnits: state.powerReserveUnits,
      foodReserveUnits: state.foodReserveUnits,
      stability: state.stability,
      habitability: state.habitability
    };

    const r = computeFor(sim, links, nowMs);

    state.gateAnomaly = r.gateDemand > 0;
    state.notice = state.heat.completed ? "OBJECTIVE COMPLETE: EVENT SURVIVAL CONFIRMED" : r.notice;

    // ---- power reserve ----
    const netPowerUnitsPerHr = r.supply - r.servedDemand;
    state.powerReserveUnits = clamp(state.powerReserveUnits + (netPowerUnitsPerHr/3600)*dtSeconds, -160, 320);

    // ---- food reserve ----
    // Food consumption is tied to Life Support being powered (population baseline).
    const lifePowered = r.served.get("life")?.served ?? false;
    const foodConsumePerHr = lifePowered ? 26 : 18; // if life support down, consumption drops (grim but systemic)
    const netFoodUnitsPerHr = r.harvFoodOutPerHr - foodConsumePerHr;
    state.foodReserveUnits = clamp(state.foodReserveUnits + (netFoodUnitsPerHr/3600)*dtSeconds, -200, 420);

    // ---- habitability ----
    // Habitability rises slowly when food reserve is healthy; drops faster when starving.
    const foodPressure = state.foodReserveUnits; // units; later translated to hours for UI
    let hab = state.habitability;

    if(foodPressure < -20) hab -= 0.010*(dtSeconds/60);
    else if(foodPressure < 10) hab -= 0.004*(dtSeconds/60);
    else if(foodPressure > 40) hab += 0.003*(dtSeconds/60);
    else hab += 0.001*(dtSeconds/60);

    // Power crises hurt habitability a bit (lights, heat, air handling quality)
    if(r.relayAOver || r.relayBOver) hab -= 0.0025*(dtSeconds/60);
    if((r.supply - r.servedDemand) < 0) hab -= 0.003*(dtSeconds/60);
    if(!lifePowered) hab -= 0.020*(dtSeconds/60);

    state.habitability = clamp(hab, 0.05, 0.99);

    // ---- stability ----
    // Stability drift is now influenced by habitability (low hab slows recovery)
    let stab = state.stability;
    const deficit = (r.supply - r.servedDemand) < 0;

    const habRecoveryFactor = clamp(0.55 + 0.55*state.habitability, 0.45, 1.05); // low hab => slower recovery
    const habDegradeFactor  = clamp(1.05 - 0.65*state.habitability, 0.55, 1.05); // low hab => more fragile

    if(!lifePowered) stab -= 0.020*(dtSeconds/60);
    if(r.relayAOver || r.relayBOver) stab -= 0.010*(dtSeconds/60) * habDegradeFactor;
    if(deficit) stab -= 0.006*(dtSeconds/60) * habDegradeFactor;
    if(!deficit && !r.relayAOver && !r.relayBOver && lifePowered && state.powerReserveUnits>10){
      stab += 0.004*(dtSeconds/60) * habRecoveryFactor;
    }
    if(state.gateAnomaly) stab -= 0.004*(dtSeconds/60) * habDegradeFactor;

    state.stability = clamp(stab, 0.05, 0.99);

    // Objective failure tracking during active heat:
    if(state.heat.active){
      if(!lifePowered) state.heat.inEventHadLife = false;
    }

    return r;
  }

  // ---------- offline progress ----------
  function applyOfflineProgress(){
    const now=Date.now();
    const last=state.tLast||now;
    const dt=clamp((now-last)/1000,0,60*60*24);
    if(dt>2) tick(dt);
    state.tLast=now;
    document.getElementById('tagTime').innerHTML = `Offline: <span class="muted">${Math.round(dt)}s</span>`;
  }

  // ---------- save/load ----------
  function save(){
    const payload={
      version:state.version,
      tLast:state.tLast,
      powerReserveUnits:state.powerReserveUnits,
      foodReserveUnits:state.foodReserveUnits,
      stability:state.stability,
      habitability:state.habitability,
      links:links.map(L=>({id:L.id,a:L.a,b:L.b})),
      heat:{...state.heat}
    };
    localStorage.setItem(SAVE_KEY,JSON.stringify(payload));
  }
  function load(){
    const raw=localStorage.getItem(SAVE_KEY);
    if(!raw) return false;
    try{
      const p=JSON.parse(raw);
      if(!p || p.version!==MODEL_VERSION) return false;

      state.tLast=p.tLast||Date.now();
      state.powerReserveUnits=typeof p.powerReserveUnits==="number"?p.powerReserveUnits:state.powerReserveUnits;
      state.foodReserveUnits=typeof p.foodReserveUnits==="number"?p.foodReserveUnits:state.foodReserveUnits;
      state.stability=typeof p.stability==="number"?p.stability:state.stability;
      state.habitability=typeof p.habitability==="number"?p.habitability:state.habitability;

      if(Array.isArray(p.links)){
        for(const savedL of p.links){
          const L=links.find(x=>x.id===savedL.id);
          if(L && savedL.a && savedL.b){ L.a=savedL.a; L.b=savedL.b; }
        }
      }
      if(p.heat){
        state.heat = {
          active: !!p.heat.active,
          target: p.heat.target || "relayB",
          reduction: typeof p.heat.reduction==="number" ? p.heat.reduction : 0.35,
          untilMs: typeof p.heat.untilMs==="number" ? p.heat.untilMs : 0,
          nextMs: typeof p.heat.nextMs==="number" ? p.heat.nextMs : (Date.now()+90_000),
          progress: typeof p.heat.progress==="number" ? p.heat.progress : 0,
          inEventHadLife: (p.heat.inEventHadLife!==undefined) ? !!p.heat.inEventHadLife : true,
          completed: !!p.heat.completed
        };
      }
      return true;
    }catch{ return false; }
  }

  function hardReset(){
    localStorage.removeItem(SAVE_KEY);
    state.tLast=Date.now();
    state.powerReserveUnits=30;
    state.foodReserveUnits=40;
    state.stability=0.84;
    state.habitability=0.88;
    state.hover=null;
    state.dragging=null;
    state.tapPick=null;
    state.notice="NO ACTIVE NOTICES";
    state.gateAnomaly=false;
    state.heat={
      active:false,
      target:"relayB",
      reduction:0.35,
      untilMs:0,
      nextMs:Date.now()+90_000,
      progress:0,
      inEventHadLife:true,
      completed:false
    };

    // restore default wiring including harvester
    const defaults=[
      ["L1",{node:"genA",port:1},{node:"relayA",port:0}],
      ["L2",{node:"genB",port:1},{node:"relayA",port:1}],
      ["L3",{node:"relayA",port:2},{node:"relayB",port:0}],
      ["L4",{node:"relayA",port:3},{node:"aux",port:3}],
      ["L5",{node:"relayB",port:1},{node:"life",port:0}],
      ["L6",{node:"relayB",port:2},{node:"gate",port:0}],
      ["L7",{node:"relayB",port:0},{node:"harv",port:0}],
    ];
    for(const [id,a,b] of defaults){
      const L=links.find(x=>x.id===id);
      if(L){ L.a=a; L.b=b; }
    }
    save();
  }

  document.getElementById('resetBtn').addEventListener('click',()=>{
    if(confirm("Reset Zone 13 v2.0? Clears save + wiring.")) hardReset();
  });

  // ---------- interaction (drag + tap routing) ----------
  let mouse={x:0,y:0};
  function screenToWorld(evt){
    const rect=canvas.getBoundingClientRect();
    return {x:evt.clientX-rect.left, y:evt.clientY-rect.top};
  }
  const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

  function portIsOccupied(nodeId,portIndex,exceptLinkId){
    for(const L of links){
      if(exceptLinkId && L.id===exceptLinkId) continue;
      if(L.a.node===nodeId && L.a.port===portIndex) return true;
      if(L.b.node===nodeId && L.b.port===portIndex) return true;
    }
    return false;
  }

  function findPortAt(pos){
    for(const n of nodes){
      for(let i=0;i<n.ports.length;i++){
        const p=portWorldPos(n,i);
        if(dist(pos,p) <= hit.portRadius+3) return {nodeId:n.id, portIndex:i};
      }
    }
    return null;
  }

  function findLinkEndAt(pos){
    for(const L of links){
      const aPos=portWorldPos(getNode(L.a.node), L.a.port);
      const bPos=portWorldPos(getNode(L.b.node), L.b.port);
      if(dist(pos,aPos) <= hit.portRadius+5) return {linkId:L.id, end:"a", x:aPos.x, y:aPos.y};
      if(dist(pos,bPos) <= hit.portRadius+5) return {linkId:L.id, end:"b", x:bPos.x, y:bPos.y};
    }
    return null;
  }

  function setHoverAt(pos){
    const port=findPortAt(pos);
    if(port){
      const n=getNode(port.nodeId);
      state.hover={kind:"port", text:`${n.name} · Port ${port.portIndex+1}`};
      return;
    }
    let best=null, bestD=1e9;
    for(const n of nodes){
      const d=Math.hypot(pos.x-n.x,pos.y-n.y);
      if(d < hit.nodeRadius && d < bestD){ best=n; bestD=d; }
    }
    state.hover = best ? {kind:"node", nodeId:best.id, text:best.name} : null;
  }

  function commitTo(pos){
    const snap=findPortAt(pos);
    if(!snap) return false;

    let linkId=null, end=null;
    if(state.dragging){ linkId=state.dragging.linkId; end=state.dragging.end; }
    else if(state.tapPick){ linkId=state.tapPick.linkId; end=state.tapPick.end; }
    else return false;

    const L=links.find(x=>x.id===linkId);
    if(!L) return false;
    if(portIsOccupied(snap.nodeId, snap.portIndex, L.id)) return false;

    const other=(end==="a")?L.b:L.a;
    if(other.node===snap.nodeId && other.port===snap.portIndex) return false;

    if(end==="a") L.a={node:snap.nodeId, port:snap.portIndex};
    else L.b={node:snap.nodeId, port:snap.portIndex};

    saveNow();
    state.dragging=null;
    state.tapPick=null;
    return true;
  }

  canvas.addEventListener('pointerdown',(evt)=>{
    evt.preventDefault();
    canvas.setPointerCapture(evt.pointerId);
    const p=screenToWorld(evt);
    mouse=p;

    if(state.tapPick){
      commitTo(p);
      return;
    }

    const end=findLinkEndAt(p);
    if(end){
      state.dragging={...end};
      state.tapPick={linkId:end.linkId, end:end.end}; // tap selects too
      return;
    }
    setHoverAt(p);
  },{passive:false});

  canvas.addEventListener('pointermove',(evt)=>{
    evt.preventDefault();
    const p=screenToWorld(evt);
    mouse=p;
    if(state.dragging){
      state.dragging.x=p.x; state.dragging.y=p.y;
    } else {
      setHoverAt(p);
    }
  },{passive:false});

  canvas.addEventListener('pointerup',(evt)=>{
    evt.preventDefault();
    const p=screenToWorld(evt);
    mouse=p;

    if(state.dragging){
      commitTo(p);
      state.dragging=null;
      return;
    }
    const port=findPortAt(p);
    if(port && state.tapPick){
      commitTo(p);
    } else {
      state.tapPick=null; // tap empty cancels
    }
  },{passive:false});

  canvas.addEventListener('pointercancel',(evt)=>{
    evt.preventDefault();
    state.dragging=null;
    state.tapPick=null;
  },{passive:false});

  // ---------- rendering ----------
  function roundRect(ctx,x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawGrid(){
    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.fillStyle="#0b0d10";
    ctx.fillRect(0,0,w,h);

    ctx.strokeStyle="rgba(255,255,255,0.05)";
    ctx.lineWidth=1;
    const step=28;
    for(let x=0;x<w;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

    const g=ctx.createRadialGradient(w*0.5,h*0.55,20,w*0.5,h*0.55,Math.max(w,h));
    g.addColorStop(0,"rgba(0,0,0,0)");
    g.addColorStop(1,"rgba(0,0,0,0.55)");
    ctx.fillStyle=g;
    ctx.fillRect(0,0,w,h);
  }

  function nodeColors(computed, nowMs){
    const colors=new Map();
    for(const n of nodes){
      let c="rgba(140,150,160,.45)";
      if(n.kind==="generator") c="rgba(105,183,255,.85)";
      if(n.kind==="consumer"){
        const served=computed.served.get(n.id)?.served;
        c=served ? "rgba(88,214,141,.85)" : "rgba(255,92,92,.9)";
      }
      if(n.kind==="relay"){
        const load=computed.relayLoads.get(n.id)||0;
        const cap=(n.id==="relayA")?computed.capA:computed.capB;
        const pct=cap>0?load/cap:2;
        if(pct<0.85) c="rgba(88,214,141,.75)";
        else if(pct<1.0) c="rgba(244,208,63,.92)";
        else c="rgba(255,92,92,.92)";
        if(state.heat.active && nowMs < state.heat.untilMs && state.heat.target===n.id){
          c="rgba(244,208,63,.95)";
        }
      }
      if(n.kind==="gate"){
        c=(computed.gateDemand>0) ? "rgba(255,92,92,.95)" : "rgba(140,150,160,.45)";
      }
      if(n.kind==="harvester"){
        c = computed.harvPowered
          ? (computed.harvEff >= 0.75 ? "rgba(181,139,255,.95)" : "rgba(181,139,255,.60)")
          : "rgba(255,92,92,.90)";
      }
      colors.set(n.id,c);
    }
    return colors;
  }

  function drawLinks(computed,t){
    const deficit=(computed.supply-computed.servedDemand)<0;
    const stressed=deficit || computed.relayAOver || computed.relayBOver;

    for(const L of links){
      const aN=getNode(L.a.node), bN=getNode(L.b.node);
      const aP=portWorldPos(aN,L.a.port);
      const bP=portWorldPos(bN,L.b.port);

      let A=aP,B=bP;
      if(state.dragging && state.dragging.linkId===L.id){
        if(state.dragging.end==="a") A={x:state.dragging.x,y:state.dragging.y};
        else B={x:state.dragging.x,y:state.dragging.y};
      }

      ctx.lineWidth=6;
      ctx.lineCap="round";
      ctx.strokeStyle="rgba(0,0,0,0.55)";
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();

      let col="rgba(88,214,141,0.85)";
      if(computed.loadPct>=0.85) col="rgba(244,208,63,0.92)";
      if(stressed) col="rgba(255,92,92,0.90)";
      if(state.tapPick && state.tapPick.linkId===L.id) col="rgba(105,183,255,0.95)";

      ctx.strokeStyle=col;
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();

      const segLen=Math.hypot(B.x-A.x,B.y-A.y);
      const dots=Math.max(2,Math.floor(segLen/90));
      for(let i=0;i<dots;i++){
        const tt=((t*0.00035)+i/dots)%1;
        const x=lerp(A.x,B.x,tt);
        const y=lerp(A.y,B.y,tt);
        ctx.fillStyle="rgba(255,255,255,0.35)";
        ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill();
      }
    }
  }

  function drawNode(n, computed, colors, t, nowMs){
    const c=colors.get(n.id)||"rgba(140,150,160,.45)";
    const pulse=0.6+0.4*Math.sin(t*0.004+(n.x+n.y)*0.01);

    // shadow
    ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.beginPath();
    ctx.ellipse(n.x+2,n.y+10,34,14,0,0,Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle="rgba(26,30,36,1)";
    roundRect(ctx,n.x-34,n.y-24,68,48,12);
    ctx.fill();

    // inner
    ctx.fillStyle="rgba(0,0,0,0.18)";
    roundRect(ctx,n.x-28,n.y-18,56,36,10);
    ctx.fill();

    // status light
    ctx.fillStyle=c;
    ctx.globalAlpha=(0.40+0.35*pulse);
    ctx.beginPath(); ctx.arc(n.x,n.y-2,10,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;

    // outline
    ctx.strokeStyle="rgba(255,255,255,0.08)";
    ctx.lineWidth=1;
    roundRect(ctx,n.x-34,n.y-24,68,48,12);
    ctx.stroke();

    // ports
    for(let i=0;i<n.ports.length;i++){
      const p=portWorldPos(n,i);
      const occupied=portIsOccupied(n.id,i,null);
      const near=Math.hypot(mouse.x-p.x,mouse.y-p.y) <= hit.portRadius+4;

      let fill="rgba(255,255,255,0.12)";
      if(occupied) fill="rgba(255,255,255,0.20)";
      if(state.tapPick && !occupied) fill="rgba(105,183,255,0.22)";
      if(state.tapPick && !occupied && near) fill="rgba(105,183,255,0.55)";
      if(state.dragging && !occupied && near) fill="rgba(244,208,63,0.95)";

      ctx.fillStyle=fill;
      ctx.beginPath(); ctx.arc(p.x,p.y, hit.portRadius-1, 0, Math.PI*2); ctx.fill();

      ctx.strokeStyle="rgba(0,0,0,0.55)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(p.x,p.y, hit.portRadius-1, 0, Math.PI*2); ctx.stroke();
    }

    // label text
    ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    let label=n.name;
    if(n.id==="relayA") label=`Relay A (${computed.capA})`;
    if(n.id==="relayB") label=`Relay B (${computed.capB})`;
    if(n.id==="gate") label = computed.gateDemand>0 ? `Gate (${computed.gateDemand})` : "Gate (LOCKED)";
    if(n.id==="genA") label="Gen A";
    if(n.id==="genB") label="Gen B";
    if(n.id==="aux") label="Aux";
    if(n.id==="life") label="Life Support";
    if(n.id==="harv"){
      const pct=Math.round(computed.harvEff*100);
      label = computed.harvPowered ? `Food Harvester (${pct}%)` : "Food Harvester (OFF)";
    }

    const tw=ctx.measureText(label).width;
    roundRect(ctx, n.x - tw/2 - 8, n.y + 26, tw + 16, 20, 8);
    ctx.fill();

    ctx.fillStyle="rgba(210,220,230,0.92)";
    ctx.fillText(label, n.x - tw/2, n.y + 40);

    // heat icon for relay targets
    if(n.kind==="relay" && state.heat.active && nowMs < state.heat.untilMs && state.heat.target===n.id){
      ctx.fillStyle="rgba(244,208,63,0.9)";
      ctx.beginPath(); ctx.arc(n.x+24,n.y-14,6,0,Math.PI*2); ctx.fill();
    }
  }

  // ---------- UI & projection ----------
  function colorForPct(p){
    const good=getComputedStyle(document.documentElement).getPropertyValue('--good').trim();
    const warn=getComputedStyle(document.documentElement).getPropertyValue('--warn').trim();
    const bad =getComputedStyle(document.documentElement).getPropertyValue('--bad').trim();
    if(p>=82) return good;
    if(p>=62) return warn;
    return bad;
  }

  function updateUI(computed){
    // translate reserve units into "hours" using CURRENT rates
    const powerDemand = Math.max(1, computed.servedDemand);
    const powerReserveHours = state.powerReserveUnits / powerDemand;
    const netPowerHoursPerHr = (computed.supply - computed.servedDemand) / powerDemand;

    // food: hours relative to consumption rate
    const lifePowered = computed.served.get("life")?.served ?? false;
    const foodConsumePerHr = lifePowered ? 26 : 18;
    const foodReserveHours = state.foodReserveUnits / Math.max(1, foodConsumePerHr);
    const netFoodHoursPerHr = (computed.harvFoodOutPerHr - foodConsumePerHr) / Math.max(1, foodConsumePerHr);

    document.getElementById('powerReserve').innerHTML =
      `${(powerReserveHours>=0?"+":"")}${powerReserveHours.toFixed(1)} hr <small>(${(netPowerHoursPerHr>=0?"+":"")}${netPowerHoursPerHr.toFixed(1)} net/hr)</small>`;

    document.getElementById('foodReserve').innerHTML =
      `${(foodReserveHours>=0?"+":"")}${foodReserveHours.toFixed(1)} hr <small>(${(netFoodHoursPerHr>=0?"+":"")}${netFoodHoursPerHr.toFixed(1)} net/hr)</small>`;

    const habPct=Math.round(state.habitability*100);
    const stabPct=Math.round(state.stability*100);

    const habEl=document.getElementById('habitPct');
    habEl.textContent=`${habPct}%`;
    habEl.style.color=colorForPct(habPct);

    const stabEl=document.getElementById('stabilityPct');
    stabEl.textContent=`${stabPct}%`;
    stabEl.style.color=colorForPct(stabPct);

    const noticeEl=document.getElementById('noticePill');
    noticeEl.textContent=state.notice;
    noticeEl.style.color =
      (state.notice.includes("CRITICAL")||state.notice.includes("WARNING"))
      ? getComputedStyle(document.documentElement).getPropertyValue('--bad').trim()
      : getComputedStyle(document.documentElement).getPropertyValue('--muted').trim();

    // objective tags
    const H=state.heat;
    const prog = `${H.progress}/3`;
    const heatTag=document.getElementById('tagHeat');
    if(H.active){
      const secs=Math.max(0, Math.round((H.untilMs-Date.now())/1000));
      heatTag.innerHTML = `Heat: <span class="warn">ACTIVE</span> <span class="muted">(${secs}s)</span> <span class="muted">${prog}</span>`;
    } else {
      const secs=Math.max(0, Math.round((H.nextMs-Date.now())/1000));
      heatTag.innerHTML = `Heat: <span class="muted">${secs}s</span> <span class="muted">${prog}</span>`;
    }

    const obj=document.getElementById('tagObjective');
    obj.innerHTML = H.completed
      ? `Objective: <span class="good">Complete</span>`
      : `Objective: <span class="muted">Survive 3 heat events</span>`;

    // hover
    const tagHover=document.getElementById('tagHover');
    if(state.hover?.kind==="node"){
      const n=getNode(state.hover.nodeId);
      tagHover.innerHTML=`Hover: <span class="muted">${n.name}</span>`;
    } else if(state.hover?.kind==="port"){
      tagHover.innerHTML=`Hover: <span class="muted">${state.hover.text}</span>`;
    } else {
      tagHover.innerHTML=`Hover: <span class="muted">None</span>`;
    }

    // mode
    const tagMode=document.getElementById('tagMode');
    if(state.dragging) tagMode.innerHTML=`Mode: <span class="cold">Dragging</span>`;
    else if(state.tapPick) tagMode.innerHTML=`Mode: <span class="cold">Tap Routing</span>`;
    else tagMode.innerHTML=`Mode: <span class="muted">Idle</span>`;
  }

  function projectMinutes(mins){
    const nowMs=Date.now();
    const sim={
      powerReserveUnits:state.powerReserveUnits,
      foodReserveUnits:state.foodReserveUnits,
      stability:state.stability,
      habitability:state.habitability
    };
    const steps=Math.max(1,Math.floor((mins*60)/6));
    const dt=(mins*60)/steps;

    // simulate forward without triggering NEW heat starts; but active heat still affects capacities (uses real state.heat data)
    for(let i=0;i<steps;i++){
      const tMs = nowMs + (i*dt*1000);
      const r=computeFor(sim, links, tMs);

      const netPowerUnitsPerHr = r.supply - r.servedDemand;
      sim.powerReserveUnits = clamp(sim.powerReserveUnits + (netPowerUnitsPerHr/3600)*dt, -160, 320);

      const lifePowered = r.served.get("life")?.served ?? false;
      const foodConsumePerHr = lifePowered ? 26 : 18;
      const netFoodUnitsPerHr = r.harvFoodOutPerHr - foodConsumePerHr;
      sim.foodReserveUnits = clamp(sim.foodReserveUnits + (netFoodUnitsPerHr/3600)*dt, -200, 420);

      let hab = sim.habitability;
      if(sim.foodReserveUnits < -20) hab -= 0.010*(dt/60);
      else if(sim.foodReserveUnits < 10) hab -= 0.004*(dt/60);
      else if(sim.foodReserveUnits > 40) hab += 0.003*(dt/60);
      else hab += 0.001*(dt/60);
      if(r.relayAOver || r.relayBOver) hab -= 0.0025*(dt/60);
      if((r.supply - r.servedDemand) < 0) hab -= 0.003*(dt/60);
      if(!lifePowered) hab -= 0.020*(dt/60);
      sim.habitability = clamp(hab, 0.05, 0.99);

      let stab = sim.stability;
      const deficit = (r.supply - r.servedDemand) < 0;

      const habRecoveryFactor = clamp(0.55 + 0.55*sim.habitability, 0.45, 1.05);
      const habDegradeFactor  = clamp(1.05 - 0.65*sim.habitability, 0.55, 1.05);

      if(!lifePowered) stab -= 0.020*(dt/60);
      if(r.relayAOver || r.relayBOver) stab -= 0.010*(dt/60)*habDegradeFactor;
      if(deficit) stab -= 0.006*(dt/60)*habDegradeFactor;
      if(!deficit && !r.relayAOver && !r.relayBOver && lifePowered && sim.powerReserveUnits>10){
        stab += 0.004*(dt/60)*habRecoveryFactor;
      }
      if(r.gateDemand>0) stab -= 0.004*(dt/60)*habDegradeFactor;

      sim.stability = clamp(stab, 0.05, 0.99);
    }

    // Convert to hours for display
    const baseNow=computeFor({stability:state.stability, habitability:state.habitability}, links, nowMs);
    const powerDemand=Math.max(1, baseNow.servedDemand);
    const lifePowered = baseNow.served.get("life")?.served ?? false;
    const foodConsumePerHr = lifePowered ? 26 : 18;

    return {
      pHours: (sim.powerReserveUnits / powerDemand),
      fHours: (sim.foodReserveUnits / Math.max(1, foodConsumePerHr)),
      hab: Math.round(sim.habitability*100),
      stab: Math.round(sim.stability*100)
    };
  }

  function updateProjectionLine(){
    const p15=projectMinutes(15), p30=projectMinutes(30), p60=projectMinutes(60);
    const fmt=(p)=>`${(p.pHours>=0?"+":"")}${p.pHours.toFixed(1)}p ${ (p.fHours>=0?"+":"")}${p.fHours.toFixed(1)}f ${p.hab}%h ${p.stab}%s`;
    document.getElementById('projLine').textContent =
      `Projection: 15m ${fmt(p15)} · 30m ${fmt(p30)} · 60m ${fmt(p60)}`;
  }

  // ---------- init/loop ----------
  function saveNow(){ state.tLast=Date.now(); save(); }

  load();
  applyOfflineProgress();
  save();

  let lastFrame=performance.now();
  let lastProj=0;

  function frame(t){
    const now=performance.now();
    const dt=clamp((now-lastFrame)/1000,0,0.05);
    lastFrame=now;

    const computed=tick(dt);

    drawGrid();
    drawLinks(computed,t);

    const nowMs=Date.now();
    const colors=nodeColors(computed,nowMs);
    for(const n of nodes) drawNode(n, computed, colors, t, nowMs);

    if(state.dragging){
      ctx.fillStyle="rgba(244,208,63,0.55)";
      ctx.beginPath(); ctx.arc(state.dragging.x,state.dragging.y,9,0,Math.PI*2); ctx.fill();
    }

    updateUI(computed);

    if(t-lastProj>2500){ updateProjectionLine(); lastProj=t; }
    if(Math.floor(t/2000)!==Math.floor((t-dt*1000)/2000)) saveNow();

    requestAnimationFrame(frame);
  }

  updateProjectionLine();
  requestAnimationFrame(frame);

  document.addEventListener('visibilitychange',()=>{
    if(document.visibilityState==="hidden"){
      saveNow();
    } else {
      load();
      applyOfflineProgress();
      updateProjectionLine();
      save();
    }
  });
})();
</script>
</body>
</html>
