<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Cascade Garden v0.4.3 (Hardened)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0b1410;font-family:system-ui;-webkit-user-select:none;user-select:none;touch-action:none}
    canvas{display:block;width:100vw;height:100vh}
    .ui{
      position:fixed;left:12px;top:12px;z-index:10;
      display:flex;gap:8px;align-items:center;flex-wrap:wrap;
      padding:10px 12px;border-radius:14px;
      background:rgba(10,18,14,.45);border:1px solid rgba(255,255,255,.10);
      backdrop-filter:blur(8px);color:rgba(255,255,255,.9)
    }
    button{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:8px 10px;border-radius:12px;cursor:pointer
    }
    button:active{transform:translateY(1px)}
    .hint{font-size:12px;opacity:.78;max-width:520px;line-height:1.15}
    .colorbar{
      position:fixed;left:12px;bottom:12px;z-index:11;
      display:none;gap:10px;align-items:center;flex-wrap:wrap;
      padding:10px 12px;border-radius:14px;
      background:rgba(10,18,14,.45);border:1px solid rgba(255,255,255,.10);
      backdrop-filter:blur(8px);color:rgba(255,255,255,.9)
    }
    .swatch{width:26px;height:26px;border-radius:10px;border:1px solid rgba(255,255,255,.25);cursor:pointer;position:relative}
    .swatch.sel::after{content:"";position:absolute;inset:-3px;border-radius:12px;border:2px solid rgba(255,255,255,.8);pointer-events:none}
    .debug{
      position:fixed;right:12px;top:12px;z-index:20;
      padding:10px 12px;border-radius:14px;
      background:rgba(0,0,0,.42);border:1px solid rgba(255,255,255,.12);
      color:rgba(255,255,255,.9);font-size:12px;max-width:560px;
      white-space:pre-wrap;line-height:1.15;
      display:none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <button id="add">Add Bamboo</button>
  <button id="rot">Rotate</button>
  <button id="reset">Reset</button>
  <button id="color">Color Mode: Off</button>
  <button id="sound">Sound: Off</button>
  <div class="hint" id="hint">Drag bamboo. Press <b>R</b> to rotate selected. If anything goes weird, v0.4.3 self-heals.</div>
</div>

<div class="colorbar" id="colorbar">
  <span style="font-size:12px;opacity:.8">Tap-to-fill:</span>
  <div id="swatches" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center"></div>
  <button id="undo">Undo</button>
  <button id="clear">Clear</button>
</div>

<div class="debug" id="debug"></div>

<script>
(() => {
  "use strict";

  const debugBox = document.getElementById("debug");
  const hint = document.getElementById("hint");
  function showDebug(msg){
    debugBox.style.display = "block";
    debugBox.textContent = msg;
  }
  function softDebug(msg){
    // show but don't stop the game
    debugBox.style.display = "block";
    debugBox.textContent = msg;
  }
  window.addEventListener("error", (e) => {
    showDebug("JS ERROR:\n" + (e.message || "Unknown") + "\n" + (e.filename||"") + ":" + (e.lineno||""));
  });

  let colorMode = false;

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  if(!ctx){ showDebug("Could not get 2D canvas context."); return; }

  const dpr = () => Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const W = () => window.innerWidth;
  const H = () => window.innerHeight;

  let rebuildColorMaps = () => {};

  function resize(){
    const r = dpr();
    canvas.width  = Math.max(1, Math.floor(W()*r));
    canvas.height = Math.max(1, Math.floor(H()*r));
    canvas.style.width = W()+"px";
    canvas.style.height = H()+"px";
    ctx.setTransform(r,0,0,r,0,0);
    if (colorMode) rebuildColorMaps();
  }
  window.addEventListener("resize", resize);
  resize();

  const source = { x: ()=> W()*0.78, y: ()=> H()*0.12 };
  const bowl = {
    cx: ()=> W()*0.55,
    cy: ()=> H()*0.82,
    rO: ()=> Math.min(W(),H())*0.12,
    rI: ()=> Math.min(W(),H())*0.085,
  };

  class Bamboo {
    constructor(x,y,len=190,rot=0){
      this.x=x; this.y=y; this.len=len; this.rot=rot;
      this.id = Math.random().toString(16).slice(2);
      this.selected=false;
    }
    mouth(){
      if (this.rot===0) return {x:this.x-this.len*0.5,y:this.y};
      if (this.rot===2) return {x:this.x+this.len*0.5,y:this.y};
      if (this.rot===1) return {x:this.x,y:this.y-this.len*0.5};
      return {x:this.x,y:this.y+this.len*0.5};
    }
    out(){
      if (this.rot===0) return {x:this.x+this.len*0.5,y:this.y+10};
      if (this.rot===2) return {x:this.x-this.len*0.5,y:this.y+10};
      if (this.rot===1) return {x:this.x,y:this.y+this.len*0.5};
      return {x:this.x,y:this.y-this.len*0.5};
    }
    rotate(){ this.rot=(this.rot+1)%4; }
    hit(px,py){
      const a=this.mouth(), b=this.out();
      const dx=b.x-a.x, dy=b.y-a.y;
      const denom = (dx*dx+dy*dy) || 1;
      const t=((px-a.x)*dx+(py-a.y)*dy)/denom;
      const tt=Math.max(0,Math.min(1,t));
      const cx=a.x+dx*tt, cy=a.y+dy*tt;
      return Math.hypot(px-cx,py-cy)<26;
    }
    draw(){
      const a=this.mouth(), b=this.out();
      ctx.save();
      ctx.lineCap="round"; ctx.lineJoin="round";
      ctx.strokeStyle="rgba(0,0,0,.28)";
      ctx.lineWidth=34;
      ctx.beginPath(); ctx.moveTo(a.x+3,a.y+6); ctx.lineTo(b.x+3,b.y+6); ctx.stroke();
      const g=ctx.createLinearGradient(a.x,a.y,b.x,b.y);
      g.addColorStop(0,"rgba(132,168,96,.92)");
      g.addColorStop(.5,"rgba(96,138,78,.92)");
      g.addColorStop(1,"rgba(132,168,96,.92)");
      ctx.strokeStyle=g;
      ctx.lineWidth=30;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      ctx.fillStyle="rgba(26,22,18,.7)";
      const m=this.mouth();
      ctx.beginPath(); ctx.ellipse(m.x,m.y,16,10,0,0,Math.PI*2); ctx.fill();
      if (this.selected){
        ctx.strokeStyle="rgba(255,255,255,.55)";
        ctx.lineWidth=3;
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      }
      ctx.restore();
    }
    drawMask(c){
      const a=this.mouth(), b=this.out();
      c.save();
      c.lineCap="round"; c.lineJoin="round";
      c.lineWidth=34;
      c.beginPath(); c.moveTo(a.x,a.y); c.lineTo(b.x,b.y); c.stroke();
      c.restore();
    }
    drawOutline(c){
      const a=this.mouth(), b=this.out();
      c.save();
      c.lineCap="round"; c.lineJoin="round";
      c.strokeStyle="rgba(20,20,20,.75)";
      c.lineWidth=4;
      c.beginPath(); c.moveTo(a.x,a.y); c.lineTo(b.x,b.y); c.stroke();
      c.restore();
    }
  }

  let bamboos=[];
  let selectedId=null;

  function select(b){
    for(const x of bamboos){ if(x) x.selected=false; }
    if (b){ b.selected=true; selectedId=b.id; }
    else selectedId=null;
  }

  function resetLayout(){
    bamboos=[];
    const baseX=W()*0.72, baseY=H()*0.18;
    const stepY=Math.min(120,H()*0.11);
    const stepX=Math.min(170,W()*0.16);
    bamboos.push(new Bamboo(baseX, baseY+1*stepY, 210, 2));
    bamboos.push(new Bamboo(baseX-stepX*0.55, baseY+2*stepY, 190, 0));
    bamboos.push(new Bamboo(baseX, baseY+3*stepY, 210, 2));
    bamboos.push(new Bamboo(baseX-stepX*0.55, baseY+4*stepY, 190, 0));
    bamboos.push(new Bamboo(baseX, baseY+5*stepY, 210, 2));
    select(null);
    if (colorMode) rebuildColorMaps();
  }
  resetLayout();

  function findBambooAt(x,y){
    for (let i=bamboos.length-1;i>=0;i--){
      const bb=bamboos[i];
      if(bb && bb.hit(x,y)) return bb;
    }
    return null;
  }

  // ----- Particles
  const rain=[], drops=[], ripples=[];
  function spawnRain(n=6){
    for(let i=0;i<n;i++){
      rain.push({x:Math.random()*W(), y:-40-Math.random()*H()*0.2, vx:-85+Math.random()*25, vy:520+Math.random()*240, len:10+Math.random()*10, w:1+Math.random()*0.6});
    }
  }
  function spawnDrop(x,y){
    drops.push({x,y, vx:(Math.random()-0.5)*10, vy:140+Math.random()*30, mode:"fall", life:3, t:0, dur:0.6, bambooId:null});
  }
  function addRipple(x,y,scale=1){ ripples.push({x,y,r:0,a:0.7*scale}); }
  function inBowl(x,y){ return Math.hypot(x-bowl.cx(), y-bowl.cy()) < bowl.rI(); }

  function tryCatch(drop){
    let best=null, bestDist=1e9;
    for(const b of bamboos){
      if(!b) continue;
      const m=b.mouth();
      const d=Math.hypot(drop.x-m.x, drop.y-m.y);
      if (d<22 && d<bestDist){ best=b; bestDist=d; }
    }
    if (!best) return false;
    drop.mode="ride"; drop.bambooId=best.id; drop.t=0; drop.dur=0.55+Math.random()*0.2;
    const m=best.mouth(); drop.x=m.x; drop.y=m.y; drop.vx=0; drop.vy=0;
    return true;
  }

  // ----- Draw
  function drawBackground(){
    const g=ctx.createLinearGradient(0,0,0,H());
    g.addColorStop(0,"#6e7f84");
    g.addColorStop(0.28,"#4a5f61");
    g.addColorStop(0.62,"#233536");
    g.addColorStop(1,"#0f1e1d");
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W(),H());
  }
  function drawBowl(){
    const cx=bowl.cx(), cy=bowl.cy(), rO=bowl.rO(), rI=bowl.rI();
    ctx.save();
    ctx.fillStyle="rgba(14,18,18,.62)";
    ctx.beginPath(); ctx.ellipse(cx,cy,rO*1.06,rO*0.64,0,0,Math.PI*2); ctx.fill();
    const wg=ctx.createRadialGradient(cx,cy-rI*0.35,rI*0.2,cx,cy,rI*1.2);
    wg.addColorStop(0,"rgba(120,200,210,0.55)");
    wg.addColorStop(1,"rgba(18,52,58,0.88)");
    ctx.fillStyle=wg;
    ctx.beginPath(); ctx.ellipse(cx,cy,rI*1.02,rI*0.62,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawSource(){
    const x=source.x(), y=source.y();
    ctx.save();
    ctx.strokeStyle="rgba(0,0,0,0.22)";
    ctx.lineWidth=34; ctx.lineCap="round";
    ctx.beginPath(); ctx.moveTo(x+40,y-6); ctx.lineTo(x-160,y-6); ctx.stroke();
    const g=ctx.createLinearGradient(x+40,y,x-160,y);
    g.addColorStop(0,"rgba(132,168,96,.92)");
    g.addColorStop(1,"rgba(96,138,78,.92)");
    ctx.strokeStyle=g;
    ctx.lineWidth=30;
    ctx.beginPath(); ctx.moveTo(x+40,y-10); ctx.lineTo(x-160,y-10); ctx.stroke();
    ctx.fillStyle="rgba(26,22,18,.7)";
    ctx.beginPath(); ctx.ellipse(x-160,y-10,16,10,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawRain(){
    ctx.save();
    ctx.strokeStyle="rgba(210,245,255,0.25)";
    for(const r of rain){
      if(!r) continue;
      ctx.lineWidth=r.w || 1;
      ctx.beginPath();
      ctx.moveTo(r.x||0,r.y||0);
      ctx.lineTo((r.x||0)-3,(r.y||0)-(r.len||10));
      ctx.stroke();
    }
    ctx.restore();
  }
  function drawRipples(){
    ctx.save();
    for(const rp of ripples){
      if(!rp) continue;
      ctx.strokeStyle=`rgba(210,245,255,${rp.a||0})`;
      ctx.lineWidth=1.6;
      ctx.beginPath();
      ctx.ellipse(rp.x||0,rp.y||0,rp.r||0,(rp.r||0)*0.55,0,0,Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }
  function drawDrops(){
    ctx.save();
    ctx.fillStyle="rgba(190,245,248,0.85)";
    for(const d of drops){
      if(!d) continue;
      ctx.beginPath(); ctx.arc(d.x||0,d.y||0,2.6,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // ----- Color Mode (kept minimal; no changes needed for your crash)
  const colorbar = document.getElementById("colorbar");
  const idMap=document.createElement("canvas");
  const idCtx=idMap.getContext("2d",{willReadFrequently:true});
  const paintLayer=document.createElement("canvas");
  const paintCtx=paintLayer.getContext("2d");
  const regionByRGB=new Map();
  const regionColors=new Map();
  const undoStack=[];

  const palette=[
    {name:"Mist",hex:"#cfd7da"},
    {name:"Slate",hex:"#7a8a91"},
    {name:"Sage",hex:"#8aa08c"},
    {name:"Moss",hex:"#5f7b63"},
    {name:"Teal",hex:"#5a8b8e"},
    {name:"Stone",hex:"#a7a6a0"},
    {name:"Clay",hex:"#8b7868"},
    {name:"Ink",hex:"#2b2f33"},
    {name:"Sky",hex:"#9fb4b8"},
    {name:"Pond",hex:"#2e5f66"},
  ];
  let activeColor=palette[2].hex;

  function rgbKey(r,g,b){ return r+","+g+","+b; }
  let cachedRegions=[];

  function buildRegions(){
    regionByRGB.clear();
    const regions=[];
    const add=(key,rgb,drawMask)=>{
      regions.push({key,rgb,drawMask});
      regionByRGB.set(rgbKey(rgb[0],rgb[1],rgb[2]), key);
    };
    add("sky",[10,0,0],(c)=>{c.beginPath();c.rect(0,0,W(),H());c.fill();});
    add("ground",[20,0,0],(c)=>{c.beginPath();c.rect(0,H()*0.62,W(),H()*0.38);c.fill();});
    add("bowl_stone",[30,0,0],(c)=>{const cx=bowl.cx(),cy=bowl.cy(),rO=bowl.rO();c.beginPath();c.ellipse(cx,cy,rO*1.08,rO*0.66,0,0,Math.PI*2);c.fill();});
    add("bowl_water",[40,0,0],(c)=>{const cx=bowl.cx(),cy=bowl.cy(),rI=bowl.rI();c.beginPath();c.ellipse(cx,cy,rI*1.02,rI*0.62,0,0,Math.PI*2);c.fill();});
    bamboos.forEach((b,i)=>{
      if(!b) return;
      const id=100+i;
      add("bamboo_"+id,[id,0,0],(c)=>{ b.drawMask(c); });
    });
    return regions;
  }

  rebuildColorMaps = function(){
    idMap.width = paintLayer.width = Math.floor(W());
    idMap.height = paintLayer.height = Math.floor(H());
    cachedRegions = buildRegions();
    idCtx.clearRect(0,0,W(),H());
    for(const r of cachedRegions){
      idCtx.fillStyle = `rgb(${r.rgb[0]},${r.rgb[1]},${r.rgb[2]})`;
      r.drawMask(idCtx);
    }
    redrawPaint();
  };

  function redrawPaint(){
    paintCtx.clearRect(0,0,W(),H());
    for(const r of cachedRegions){
      const col = regionColors.get(r.key);
      if (!col) continue;
      paintCtx.fillStyle = col;
      r.drawMask(paintCtx);
    }
  }
  function pickRegion(x,y){
    const d=idCtx.getImageData(Math.floor(x),Math.floor(y),1,1).data;
    return regionByRGB.get(rgbKey(d[0],d[1],d[2])) || null;
  }
  function fillRegion(key,col){
    const prev = regionColors.get(key) || null;
    if (prev === col) return;
    undoStack.push({key,prev});
    if (undoStack.length>80) undoStack.shift();
    regionColors.set(key,col);
    redrawPaint();
  }
  function undo(){
    const s=undoStack.pop();
    if(!s) return;
    if (s.prev===null) regionColors.delete(s.key);
    else regionColors.set(s.key,s.prev);
    redrawPaint();
  }
  function clearColors(){
    regionColors.clear();
    undoStack.length=0;
    redrawPaint();
  }
  function drawColorMode(){
    ctx.fillStyle="#eef2f3";
    ctx.fillRect(0,0,W(),H());
    ctx.drawImage(paintLayer,0,0);

    ctx.save();
    ctx.strokeStyle="rgba(20,20,20,.65)";
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.rect(0,H()*0.62,W(),H()*0.38); ctx.stroke();
    const cx=bowl.cx(),cy=bowl.cy(),rO=bowl.rO(),rI=bowl.rI();
    ctx.beginPath(); ctx.ellipse(cx,cy,rO*1.08,rO*0.66,0,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(cx,cy,rI*1.02,rI*0.62,0,0,Math.PI*2); ctx.stroke();
    for(const b of bamboos){ if(b) b.drawOutline(ctx); }
    ctx.restore();
  }

  // palette UI
  const swatches = document.getElementById("swatches");
  function renderSwatches(){
    swatches.innerHTML="";
    for(const p of palette){
      const d=document.createElement("div");
      d.className="swatch"+(p.hex===activeColor?" sel":"");
      d.style.background=p.hex;
      d.title=p.name;
      d.addEventListener("click",()=>{activeColor=p.hex; renderSwatches();});
      swatches.appendChild(d);
    }
  }
  renderSwatches();

  // Audio (optional)
  let audioOn=false, audioCtx=null, noiseNode=null, filterNode=null, gainNode=null;
  function startAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const len = audioCtx.sampleRate*2;
    const buf = audioCtx.createBuffer(1,len,audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0;i<len;i++) data[i]=Math.random()*2-1;
    noiseNode = audioCtx.createBufferSource();
    noiseNode.buffer=buf; noiseNode.loop=true;
    filterNode = audioCtx.createBiquadFilter();
    filterNode.type="lowpass"; filterNode.frequency.value=900;
    gainNode = audioCtx.createGain();
    gainNode.gain.value=0.0;
    noiseNode.connect(filterNode);
    filterNode.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    noiseNode.start();
  }
  function setSound(on){
    audioOn=on;
    document.getElementById("sound").textContent = "Sound: " + (on?"On":"Off");
    if(on){ try{ startAudio(); audioCtx.resume?.(); }catch(e){} }
  }
  setSound(false);

  // UI handlers
  document.getElementById("add").onclick=()=>{
    if(colorMode) return;
    bamboos.push(new Bamboo(W()*0.5+(Math.random()-0.5)*240, H()*0.45+(Math.random()-0.5)*240, 160+Math.random()*80, Math.floor(Math.random()*4)));
    select(bamboos[bamboos.length-1]);
  };
  document.getElementById("rot").onclick=()=>{
    if(colorMode) return;
    if(!selectedId) return;
    const b=bamboos.find(x=>x && x.id===selectedId);
    if(b) b.rotate();
  };
  document.getElementById("reset").onclick=()=>{
    resetLayout();
    rain.length=0; drops.length=0; ripples.length=0;
    clearColors();
    debugBox.style.display="none";
  };
  document.getElementById("color").onclick=()=>{
    colorMode = !colorMode;
    document.getElementById("color").textContent = "Color Mode: " + (colorMode?"On":"Off");
    colorbar.style.display = colorMode ? "flex" : "none";
    select(null);
    if(colorMode) rebuildColorMaps();
  };
  document.getElementById("sound").onclick=()=>setSound(!audioOn);
  document.getElementById("undo").onclick=()=>undo();
  document.getElementById("clear").onclick=()=>clearColors();

  window.addEventListener("keydown",(e)=>{
    if(colorMode){
      if(e.key==="z"||e.key==="Z") undo();
      return;
    }
    if((e.key==="r"||e.key==="R") && selectedId){
      const b=bamboos.find(x=>x && x.id===selectedId);
      if(b) b.rotate();
    }
  });

  // Pointer
  let dragging=false, dragId=null, ox=0, oy=0;
  canvas.addEventListener("pointerdown",(e)=>{
    const x=e.clientX, y=e.clientY;
    canvas.setPointerCapture(e.pointerId);
    if(colorMode){
      const key = pickRegion(x,y);
      if(key) fillRegion(key, activeColor);
      return;
    }
    const b=findBambooAt(x,y);
    if(!b){ select(null); return; }
    select(b);
    dragging=true; dragId=b.id;
    ox = x - b.x; oy = y - b.y;
  });
  canvas.addEventListener("pointermove",(e)=>{
    if(colorMode || !dragging) return;
    const b=bamboos.find(x=>x && x.id===dragId);
    if(!b) return;
    b.x = e.clientX - ox;
    b.y = e.clientY - oy;
  });
  canvas.addEventListener("pointerup",(e)=>{
    dragging=false; dragId=null;
    try{ canvas.releasePointerCapture(e.pointerId); }catch{}
  });

  // ----- Loop (hardened)
  let last=performance.now();
  let dripAcc=0;
  let frameCount=0;

  function sanitizeArrays(){
    const before = { b:bamboos.length, r:rain.length, d:drops.length, p:ripples.length };
    const b2 = bamboos.filter(Boolean);
    const r2 = rain.filter(Boolean);
    const d2 = drops.filter(Boolean);
    const p2 = ripples.filter(Boolean);
    if (b2.length!==before.b || r2.length!==before.r || d2.length!==before.d || p2.length!==before.p){
      softDebug(
        "Recovered from a bad entry (undefined) ✅\n" +
        `bamboos: ${before.b}→${b2.length}\n` +
        `rain:    ${before.r}→${r2.length}\n` +
        `drops:   ${before.d}→${d2.length}\n` +
        `ripples: ${before.p}→${p2.length}\n`
      );
    }
    bamboos = b2; rain.length=0; rain.push(...r2);
    drops.length=0; drops.push(...d2);
    ripples.length=0; ripples.push(...p2);
  }

  function loop(now){
    try{
      sanitizeArrays();

      const dtRaw = Math.min(0.033,(now-last)/1000);
      last=now;
      const dt = colorMode ? 0 : dtRaw;

      if(audioOn && gainNode && audioCtx){
        const target = colorMode ? 0.045 : 0.038;
        gainNode.gain.setTargetAtTime(target, audioCtx.currentTime, 0.10);
        if(filterNode){
          const wob = (Math.sin(now*0.00055)+1)*0.5;
          filterNode.frequency.setTargetAtTime((colorMode?760:680)+wob*420, audioCtx.currentTime, 0.08);
        }
      }

      if(!colorMode){
        spawnRain(6);

        for(const r of rain){
          r.x += r.vx*dt; r.y += r.vy*dt;
        }
        for(let i=rain.length-1;i>=0;i--){
          const r=rain[i];
          if(r.y > H()-40){
            addRipple(r.x,H()-40,0.35);
            r.y = -40; r.x = Math.random()*W();
          }
          if(r.x < -60) r.x = W()+60;
        }
        if(rain.length>420) rain.splice(0, rain.length-420);

        dripAcc += dt;
        while(dripAcc > 1/65){
          dripAcc -= 1/65;
          spawnDrop(source.x()-160 + (Math.random()-0.5)*3, source.y()-2 + (Math.random()-0.5)*2);
        }

        for(let i=drops.length-1;i>=0;i--){
          const d=drops[i];
          d.life -= dt;
          if(d.life<=0){ drops.splice(i,1); continue; }

          if(d.mode==="fall"){
            d.vy += 420*dt;
            d.x += d.vx*dt;
            d.y += d.vy*dt;

            tryCatch(d);

            if(inBowl(d.x,d.y)){
              addRipple(d.x,d.y,1.0);
              d.y -= 16 + Math.random()*10;
              d.vy *= 0.2;
            }
            if(d.y > H()-18){
              addRipple(d.x,H()-40,0.35);
              d.x = source.x()-160;
              d.y = -40;
              d.vy = 130 + Math.random()*40;
            }
          } else {
            const b=bamboos.find(x=>x && x.id===d.bambooId);
            if(!b){ d.mode="fall"; continue; }
            d.t += dt / d.dur;
            const u=Math.min(1,d.t);
            const ease = u<0.5 ? 2*u*u : 1 - Math.pow(-2*u+2,2)/2;
            const m=b.mouth(), o=b.out();
            d.x = m.x + (o.x-m.x)*ease;
            d.y = m.y + (o.y-m.y)*ease;
            if(u>=1){
              d.mode="fall";
              d.t=0;
              d.vx=(Math.random()-0.5)*12;
              d.vy=120+Math.random()*40;
            }
          }
        }

        for(let i=ripples.length-1;i>=0;i--){
          const rp=ripples[i];
          rp.r += 90*dt;
          rp.a -= 0.75*dt;
          if(rp.a<=0) ripples.splice(i,1);
        }
      }

      ctx.clearRect(0,0,W(),H());
      if(colorMode){
        drawColorMode();
      } else {
        drawBackground();
        drawBowl();
        drawRipples();
        drawSource();

        // safe sort: no .y access on undefined
        const sorted = bamboos.slice().filter(Boolean).sort((a,b)=> (a?.y ?? 0) - (b?.y ?? 0));
        for(const bb of sorted) bb.draw();

        drawRain();
        drawDrops();
      }

      frameCount++;
      ctx.save();
      ctx.globalAlpha=0.8;
      ctx.fillStyle="#ffffff";
      ctx.beginPath();
      ctx.arc(18, H()-18, 4 + (frameCount%40===0?2:0), 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      requestAnimationFrame(loop);
    } catch(err){
      showDebug("LOOP CRASH:\n" + (err?.message || String(err)));
    }
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
